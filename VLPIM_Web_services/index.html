<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VLPIM - Immunogenicity Modulation Tool</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svd-js@1.4.1/dist/svd.min.js"></script>
    <script>
        // Verify SVD library is loaded
        window.addEventListener('load', function() {
            if (typeof SVDJS === 'undefined' && typeof window.SVDJS === 'undefined' && typeof window.SVD === 'undefined' && typeof SVD === 'undefined') {
                console.warn('SVD library may not be loaded correctly. RMSD calculation may fail.');
            } else {
                console.log('SVD library loaded successfully');
            }
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --light-bg: #f8f9fa;
            --border-color: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #333;
            background: #fff;
            line-height: 1.6;
        }

        /* Navigation */
        .navbar-custom {
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 1rem 0;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-brand {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
            text-decoration: none;
        }

        .nav-menu {
            display: flex;
            list-style: none;
            gap: 2rem;
            align-items: center;
        }

        .nav-group {
            display: flex;
            gap: 1.5rem;
            align-items: center;
        }

        .nav-item {
            position: relative;
        }

        .nav-link {
            color: #555;
            text-decoration: none;
            font-weight: 500;
            padding: 0.5rem 0;
            transition: color 0.3s;
            cursor: pointer;
        }

        .nav-link:hover {
            color: var(--secondary-color);
        }

        .nav-link.active {
            color: var(--secondary-color);
            border-bottom: 2px solid var(--secondary-color);
        }

        /* Hero Section */
        .hero-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 80px 20px;
            text-align: center;
        }

        .hero-content {
            max-width: 900px;
            margin: 0 auto;
        }

        .hero-title {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            line-height: 1.2;
        }

        .hero-subtitle {
            font-size: 1.3rem;
            margin-bottom: 2rem;
            opacity: 0.95;
        }

        .hero-description {
            font-size: 1.1rem;
            max-width: 700px;
            margin: 0 auto 2rem;
            opacity: 0.9;
        }

        .hero-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 2rem;
        }

        .btn-hero {
            padding: 12px 30px;
            font-size: 1rem;
            border-radius: 25px;
            border: none;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            font-weight: 600;
            min-width: 200px;
        }

        .btn-hero-primary {
            background: white;
            color: var(--secondary-color);
        }

        .btn-hero-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn-hero-outline {
            background: transparent;
            color: white;
            border: 2px solid white;
        }

        .btn-hero-white {
            background: white;
            color: #333;
            border: 1px solid var(--border-color);
        }

        .btn-hero-outline:hover {
            background: white;
            color: var(--secondary-color);
            transform: translateY(-2px);
        }

        /* Main Content */
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .section {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            overflow: hidden;
        }

        .section-header {
            padding: 25px 30px;
            border-bottom: 1px solid var(--border-color);
            background: var(--light-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary-color);
            margin: 0;
        }

        .section-body {
            padding: 30px;
        }

        /* Upload Section */
        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: var(--light-bg);
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: var(--secondary-color);
            background: #f0f4f8;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin: 20px 0;
        }

        .file-label {
            display: inline-block;
            padding: 12px 30px;
            background: var(--secondary-color);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }

        .file-label:hover {
            background: #2980b9;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }

        .mode-selection {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 20px 0;
        }

        .mode-radio {
            display: none;
        }

        .mode-label {
            padding: 10px 25px;
            border: 2px solid var(--border-color);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .mode-radio:checked + .mode-label {
            background: var(--secondary-color);
            color: white;
            border-color: var(--secondary-color);
        }

        /* Tables */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .data-table th,
        .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .data-table th {
            background: var(--light-bg);
            font-weight: 600;
            color: var(--primary-color);
        }

        .data-table tr:hover {
            background: #f8f9fa;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .badge-info {
            background: #e3f2fd;
            color: #1976d2;
        }

        .score-bar {
            width: 100%;
            height: 24px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
        }

        .score-fill {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8em;
            font-weight: 600;
        }

        .score-high { background: #27ae60; }
        .score-medium { background: #f39c12; }
        .score-low { background: #e74c3c; }

        /* Footer */
        .footer {
            background: var(--primary-color);
            color: white;
            padding: 40px 20px;
            text-align: center;
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .footer-link {
            color: white;
            text-decoration: none;
            transition: color 0.3s;
        }

        .footer-link:hover {
            color: #bdc3c7;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-state i {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .hero-title {
                font-size: 2rem;
            }

            .nav-menu {
                flex-direction: column;
                gap: 1rem;
            }

            .nav-group {
                flex-direction: column;
                gap: 0.5rem;
            }
        }

        .alert {
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }

        .alert-error {
            background: #fee;
            color: #c33;
            border: 1px solid #fcc;
        }

        .alert-success {
            background: #efe;
            color: #2c3;
            border: 1px solid #cfc;
        }

        .alert-warning {
            background: #ffe;
            color: #c83;
            border: 1px solid #fc9;
        }

        .alert-info {
            background: #eef;
            color: #338;
            border: 1px solid #ccf;
        }

        .badge-success {
            background: #27ae60;
            color: white;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Navigation -->
        <nav class="navbar-custom">
            <div class="nav-container">
                <a href="#home" class="nav-brand">
                    <i class="fas fa-dna"></i> VLPIM
                </a>
                <ul class="nav-menu">
                    <div class="nav-group">
                        <li class="nav-item">
                            <a class="nav-link" :class="{active: currentSection === 'epitope'}" @click="scrollTo('epitope')">Epitope identify</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" :class="{active: currentSection === 'analyze'}" @click="scrollTo('analyze')">Immunogenicity analyze</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" :class="{active: currentSection === 'structure'}" @click="scrollTo('structure')">Structural superposition</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="toolset.html" target="_blank">Toolset</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="readme.html" target="_blank">Readme</a>
                        </li>
                    </div>
                    <div class="nav-group">
                        <li class="nav-item">
                            <a class="nav-link" :class="{active: currentSection === 'docs'}" @click="scrollTo('docs')">Documents</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" :class="{active: currentSection === 'cite'}" @click="scrollTo('cite')">Cite us</a>
                        </li>
                    </div>
                </ul>
            </div>
        </nav>

        <!-- Hero Section -->
        <section class="hero-section" id="home">
            <div class="hero-content">
                <h1 class="hero-title">VLPIM</h1>
                <h2 class="hero-subtitle">A comprehensive tool for immunogenicity modulation of virus-like particles</h2>
                <p class="hero-description">
                    An integrated computational workflow for modulating protein immunogenicity through epitope identification, 
                    MHC-II binding evaluation, and structural superposition.
                </p>
                <div style="margin-top: 1rem;">
                    <small style="opacity: 0.9;">
                        <i class="fas fa-eye"></i> Page views: <span id="pageViews">{{ pageViews }}</span>
                    </small>
                </div>
                <div class="hero-buttons">
                    <button class="btn-hero btn-hero-primary" @click="scrollTo('epitope')">
                        <i class="fas fa-search"></i> Epitope identify
                    </button>
                    <button class="btn-hero btn-hero-primary" @click="scrollTo('analyze')">
                        <i class="fas fa-chart-line"></i> Immunogenicity analyze
                    </button>
                    <button class="btn-hero btn-hero-primary" @click="scrollTo('structure')">
                        <i class="fas fa-cube"></i> Structural superposition
                    </button>
                    <button class="btn-hero btn-hero-outline" @click="scrollTo('docs')">
                        <i class="fas fa-book"></i> View documentation
                    </button>
                </div>
            </div>
        </section>

        <!-- Main Content Container -->
        <div class="main-container">
            <!-- Epitope Identify Section -->
            <section class="section" id="epitope">
                <div class="section-header">
                    <h2 class="section-title">
                        <i class="fas fa-search"></i> Step 1:Epitope identify
                    </h2>
                </div>
                <div class="section-body">
                    <p>VLPIM uses <strong>NetMHCIIpan</strong> for CD4+ T-cell epitope identification.</p>
                    
                    <div class="upload-area mt-4">
                        <h3>Upload files for epitope identification</h3>
                        <p class="text-muted mb-3">Upload NetMHCIIpan output file and enter VLP sequence for analysis</p>
                        
                        <div class="row g-3">
                            <div class="col-md-6">
                                <div class="file-input-wrapper">
                                    <label for="netmhciiFile" class="file-label">
                                        <i class="fas fa-file-upload"></i> NetMHCIIpan output file
                                    </label>
                                    <input type="file" id="netmhciiFile" class="file-input" accept=".txt,.xls,.xlsx" @change="handleNetMHCIIUpload">
                                </div>
                                <div v-if="isNetmhciiLoading" class="mt-2">
                                    <span class="badge badge-info">Loading example...</span>
                                </div>
                                <div v-else-if="netmhciiFileName" class="mt-2">
                                    <span class="badge badge-info">{{ netmhciiFileName }}</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <label for="vlpSequence" class="form-label">
                                    <i class="fas fa-dna"></i> VLP sequence (amino acids)
                                    <span v-if="vlpSequenceLength > 0" class="badge badge-info ms-2">Length: {{ vlpSequenceLength }}</span>
                                </label>
                                <textarea 
                                    id="vlpSequence" 
                                    class="form-control" 
                                    rows="4" 
                                    placeholder="Enter amino acid sequence (e.g., MKTAYIAKQR...)" 
                                    v-model="vlpSequenceText"
                                    @input="validateVlpSequence"
                                    style="font-family: 'Courier New', monospace; font-size: 0.9em;">
                                </textarea>
                                <div v-if="vlpSequenceError" class="mt-2">
                                    <small class="text-danger">
                                        <i class="fas fa-exclamation-triangle"></i> {{ vlpSequenceError }}
                                    </small>
                                </div>
                                <div v-else-if="vlpSequenceLength > 0 && !vlpSequenceError" class="mt-2">
                                    <small class="text-success">
                                        <i class="fas fa-check-circle"></i> Valid amino acid sequence
                                    </small>
                                </div>
                            </div>
                        </div>

                        <div class="mt-3">
                            <small class="text-muted">
                                Supports NetMHCIIpan output formats: standard text output (.txt) or website format (.xls/.xlsx)
                            </small>
                        </div>
                        
                        <div class="mt-3 d-flex justify-content-center">
                            <button class="btn btn-hero btn-hero-white" @click="loadEpitopeExample">
                                <i class="fas fa-download"></i> Load example
                            </button>
                        </div>

                        <div class="mt-4 d-flex align-items-center justify-content-center" style="gap:12px; flex-wrap:nowrap;">
                            <div class="d-flex align-items-center" style="gap:8px; white-space:nowrap;">
                                <label class="mode-label" for="epitopesNumber" style="border:none;">Top N epitopes</label>
                                <input id="epitopesNumber" type="number" min="1" max="50" v-model.number="epitopesNumber" class="form-control" style="width:80px; display:inline-block;">
                            </div>
                            <div class="d-flex align-items-center" style="gap:8px; white-space:nowrap;">
                                <label class="mode-label" for="epitopeLen" style="border:none;">Target length</label>
                                <select id="epitopeLen" class="form-select" v-model.number="epitopeLength" style="width:80px; display: inline-block;">
                                    <option :value="9">9</option>
                                    <option :value="10">10</option>
                                    <option :value="11">11</option>
                                    <option :value="12">12</option>
                                    <option :value="13">13</option>
                                    <option :value="14">14</option>
                                    <option :value="15">15</option>
                                </select>
                            </div>
                            <div class="mode-selection" style="margin:0; white-space:nowrap;">
                                <input type="radio" id="advEnhance" class="mode-radio" value="enhance" v-model="analysisMode">
                                <label for="advEnhance" class="mode-label">
                                    <i class="fas fa-arrow-up"></i> Enhance
                                </label>
                                <input type="radio" id="advReduce" class="mode-radio" value="reduce" v-model="analysisMode">
                                <label for="advReduce" class="mode-label">
                                    <i class="fas fa-arrow-down"></i> Reduce
                                </label>
                            </div>
                        </div>
                        <div class="mt-2">
                            <small class="text-muted">
                                <strong>Target length:</strong> Extends core sequences to the specified length (9-15 aa) using amino acids from the VLP sequence. 
                                If core is already at or above target length, it remains unchanged.
                            </small>
                        </div>
                        
                        <div class="mt-4 w-100 d-flex justify-content-center" style="gap:12px;">
                            <button class="btn btn-primary" @click="runAdvancedEpitopeAnalysis" :disabled="!netmhciiFileContent || !vlpSequenceText || vlpSequenceError || vlpSequenceLength === 0">
                                <i class="fas fa-microscope"></i> epitopes identification
                            </button>
                            <button class="btn btn-success" @click="exportAdvancedEpitopes" :disabled="!advancedEpitopes || !advancedEpitopes.length">
                                <i class="fas fa-file-export"></i> Export extended epitopes
                            </button>
                        </div>
                        
                        <div v-if="epitopeProcessing.active" class="w-100 mt-3">
                            <div class="progress" style="height: 8px;">
                                <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" :style="`width:${epitopeProcessing.value}%`"></div>
                            </div>
                            <small class="text-muted">Analyzing epitopes... {{ epitopeProcessing.value }}%</small>
                        </div>
                        
                        <!-- Error message display -->
                        <div v-if="errorMessage" class="mt-3">
                            <div class="alert alert-error">
                                <i class="fas fa-exclamation-triangle"></i> {{ errorMessage }}
                            </div>
                        </div>
                        
                        <!-- Results display -->
                        <div v-if="advancedEpitopes && advancedEpitopes.length" class="mt-4">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h4>Identified epitopes ({{ advancedEpitopes.length }})</h4>
                            </div>
                            <div class="table-responsive">
                                <table class="data-table">
                                    <thead>
                                        <tr>
                                            <th>Sequence</th>
                                            <th>Length</th>
                                            <th>Start</th>
                                            <th>End</th>
                                            <th>Core</th>
                                            <th>Allele</th>
                                            <th>IC50 (nM)</th>
                                            <th>%Rank_EL</th>
                                            <th>Binding Count</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr v-for="(row, idx) in advancedEpitopes" :key="idx">
                                            <td><code>{{ row.sequence }}</code></td>
                                            <td><strong>{{ (row.sequence || '').length }}</strong></td>
                                            <td>{{ row.start }}</td>
                                            <td>{{ row.end }}</td>
                                            <td><code>{{ row.core }}</code></td>
                                            <td><span class="badge badge-info">{{ row.allele || '-' }}</span></td>
                                            <td>{{ row.ic50 || '-' }}</td>
                                            <td>{{ row.rank_el || row.rank || '-' }}</td>
                                            <td>{{ row.number_of_strong_binding || 0 }}</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Epitope Results -->
                    <div v-if="epitopeRows && epitopeRows.length" class="mt-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h4>Identified epitopes</h4>
                            <div class="d-flex align-items-center gap-3">
                                <div class="mode-selection" style="margin:0">
                                    <input type="radio" id="epitopeModeEnhance" class="mode-radio" value="enhance" v-model="epitopeMode">
                                    <label for="epitopeModeEnhance" class="mode-label">
                                        <i class="fas fa-arrow-up"></i> Enhance
                                    </label>
                                    <input type="radio" id="epitopeModeReduce" class="mode-radio" value="reduce" v-model="epitopeMode">
                                    <label for="epitopeModeReduce" class="mode-label">
                                        <i class="fas fa-arrow-down"></i> Reduce
                                    </label>
                                </div>
                                <button class="btn btn-sm btn-success" @click="exportEpitopes">
                                    <i class="fas fa-file-export"></i> Export CSV
                                </button>
                            </div>
                        </div>
                        <div class="table-responsive">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Peptide</th>
                                        <th>Allele</th>
                                        <th>IC50 (nM)</th>
                                        <th>Rank (%)</th>
                                        <th>Position</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="(row, index) in epitopeRows" :key="index">
                                        <td><code>{{ row.Peptide || row.peptide }}</code></td>
                                        <td><span class="badge badge-info">{{ row.Allele || row.allele }}</span></td>
                                        <td>{{ row['BA_IC50'] || row.IC50 || row.ic50 || '-' }}</td>
                                        <td>{{ row.Rank || row.rank || '-' }}</td>
                                        <td>{{ row.Pos || row.pos || '-' }}</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <h5 class="mt-4">Key features:</h5>
                    <ul class="mt-3">
                        <li>Epitope prediction for full VLP sequence using NetMHCIIpan</li>
                        <li>Multi-allele HLA-DRB1 binding evaluation</li>
                        <li>Epitope rank by binding performence (sum of strong and weak binding)</li>
                        <li>Customizable peptide length and number of epitopes (default: 15 amino acids and 10 epitopes)</li>
                    </ul>
                    <div class="alert alert-info mt-4">
                        <i class="fas fa-info-circle"></i>
                        <strong>Note:</strong> Epitope identification requires NetMHCIIpan prediction results (webservice: https://services.healthtech.dtu.dk/services/NetMHCIIpan-4.3/). Example files are provided at the bottom of this tool framework.
                    </div>
                </div>
            </section>

            <!-- Immunogenicity Analyze Section -->
            <section class="section" id="analyze">
                <div class="section-header">
                    <h2 class="section-title">
                        <i class="fas fa-chart-line"></i> Step 4.1: Immunogenicity analysis
                    </h2>
                </div>
                <div class="section-body">
                    <div class="upload-area">
                        <h3>Upload files for immunogenicity analysis</h3>
                        <p class="text-muted mb-3">Upload NetMHCIIpan output file，then choose mode and compute.</p>
                        
                        <div class="mode-selection">
                            <input type="radio" id="modeEnhance" class="mode-radio" value="enhance" v-model="wy2Mode">
                            <label for="modeEnhance" class="mode-label">
                                <i class="fas fa-arrow-up"></i> Enhance mode
                            </label>
                            <input type="radio" id="modeReduce" class="mode-radio" value="reduce" v-model="wy2Mode">
                            <label for="modeReduce" class="mode-label">
                                <i class="fas fa-arrow-down"></i> Reduce mode
                            </label>
                        </div>

                        <div class="file-input-wrapper">
                            <label for="csvFile" class="file-label">
                                <i class="fas fa-file-upload"></i> NetMHCIIpan output file
                            </label>
                            <input type="file" id="csvFile" class="file-input" accept=".csv,.txt,.xls,.xlsx" @change="handleWy2Csv">
                        </div>
                        <div class="mt-2">
                            <small class="text-muted">
                                Supports NetMHCIIpan output formats: standard text output (.txt) or website format (.xls/.xlsx)
                            </small>
                        </div>
                        <div v-if="isCsvLoading" class="mt-2"><span class="badge badge-info">Loading example...</span></div>
                        
                        <div v-if="wy2CsvName" class="mt-3">
                            <span class="badge badge-info">{{ wy2CsvName }}</span>
                        </div>

                        <div class="mt-3">
                            <small class="text-muted">
                                Output will appear in the tables below and can be exported.
                            </small>
                        </div>

                        <div class="mt-4">
                            <button class="btn-hero btn-hero-primary" @click="processWy2" :disabled="!wy2CsvText">
                                <i class="fas fa-chart-bar"></i> Compute S<sup>im</sup> scores
                            </button>
                            <div v-if="wy2Processing.active" class="mt-3">
                                <div class="progress" style="height: 8px;">
                                    <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" :style="`width:${wy2Processing.value}%`"></div>
                                </div>
                                <small class="text-muted">Computing... {{ wy2Processing.value }}%</small>
                            </div>
                        </div>
                    </div>

                    <!-- Peptide Results (merged with ID) -->
                    <div v-if="(wy2Peptides && wy2Peptides.length) || (peptideRows && peptideRows.length)" class="mt-4">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h4>Peptide immunogenicity scores</h4>
                            <div class="d-flex align-items-center gap-2">
                                <select class="form-select form-select-sm" v-model="peptideSortBy" style="width:200px">
                                    <option value="overall">Sort by overall score</option>
                                    <option value="ic50">Sort by best IC50</option>
                                    <option value="alleles">Sort by allele count</option>
                                </select>
                                <button class="btn btn-sm btn-success" @click="exportWy2Combined" :disabled="!wy2Peptides.length">
                                    <i class="fas fa-file-export"></i> Export CSV
                                </button>
                            </div>
                        </div>
                        <div class="table-responsive">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Rank</th>
                                        <th>ID</th>
                                        <th>Peptide</th>
                                        <th>Alleles</th>
                                        <th>Best IC50 (nM)</th>
                                        <th>S<sup>im</sup> score</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="(row, idx) in sortedPeptides" :key="row.Peptide">
                                        <td><strong>{{ row.Rank || (idx + 1) }}</strong></td>
                                        <td><code>{{ row.ID || '-' }}</code></td>
                                        <td><code>{{ row.Peptide }}</code></td>
                                        <td><span class="badge badge-info">{{ row.Allele_Count || row.Alleles || '-' }}</span></td>
                                        <td>{{ row.Best_IC50 || row['Best_IC50(nM)'] || '-' }}</td>
                                        <td>
                                            <div class="score-bar">
                                                <div class="score-fill" :class="scoreClass(row.Overall)" 
                                                     :style="`width:${Math.min(100, Number(row.Overall))}%`">
                                                    {{ row.Overall }}
                                                </div>
                                            </div>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <h5 class="mt-4">Key features:</h5>
                    <ul class="mt-3">
                        <li>Enhance and reduce modes to prioritize sequences or peptides</li>
                        <li>Sorting by overall score, best IC50, or allele count</li>
                        <li>Export combined results to CSV with one click</li>
                    </ul>

                    <div class="alert alert-info mt-4">
                        <i class="fas fa-info-circle"></i>
                                <strong>Note:</strong> Immunogenicity analysis computes S<sup>im</sup> scores from NetMHCIIpan prediction results (https://services.healthtech.dtu.dk/services/NetMHCIIpan-4.3/). Example files are provided at the bottom of this tool framework.
                    </div>
                </div>
            </section>

            <!-- Structural superposition Section -->
            <section class="section" id="structure">
                <div class="section-header">
                    <h2 class="section-title">
                        <i class="fas fa-cube"></i> Step 4.2: Structural superposition
                    </h2>
                </div>
                <div class="section-body">
                    <p>Upload AlphaFold3 predicted structures and compare with reference structures using <strong>RMSD analysis</strong>.</p>
                    
                    <div class="upload-area mt-4">
                        <h5 class="mb-3">RMSD structure comparison</h5>
                        <p class="text-muted mb-3">Upload reference structure (original PDB) and predicted structure (AF3 result PDB) to calculate RMSD.</p>
                        
                        <div class="row g-3">
                            <div class="col-md-6">
                                <label class="file-label" for="referencePdb">
                                    <i class="fas fa-file-upload"></i> Reference structure (PDB/CIF)
                                </label>
                                <input type="file" id="referencePdb" class="file-input" accept=".pdb,.cif" @change="handlePdbUpload('reference', $event)">
                                <div v-if="referenceFileName" class="mt-2">
                                    <span class="badge badge-info">{{ referenceFileName }}</span>
                                </div>
                                <div v-if="isRefLoading" class="mt-2"><span class="badge badge-info">Loading example...</span></div>
                            </div>
                            <div class="col-md-6">
                                <label class="file-label" for="predictedPdb">
                                    <i class="fas fa-file-upload"></i> Predicted structure (PDB/CIF)
                                </label>
                                <input type="file" id="predictedPdb" class="file-input" accept=".pdb,.cif" @change="handlePdbUpload('predicted', $event)">
                                <div v-if="predictedFileName" class="mt-2">
                                    <span class="badge badge-info">{{ predictedFileName }}</span>
                                </div>
                                <div v-if="isPredLoading" class="mt-2"><span class="badge badge-info">Loading example...</span></div>
                            </div>
                        </div>

                        <div class="mt-4 d-flex align-items-center justify-content-center" style="gap:12px; flex-wrap:wrap;">
                            <div class="d-flex align-items-center" style="gap:8px; white-space:nowrap;">
                                <label class="mode-label" for="rmsdMethod" style="border:none;">Method</label>
                                <select id="rmsdMethod" class="form-select" v-model="rmsdMethod" style="width:140px; display:inline-block;">
                                    <option value="kabsch">Kabsch</option>
                                    <option value="iterative">Iterative</option>
                                    <option value="tmalign">TM-align</option>
                                </select>
                            </div>
                            <div v-if="rmsdMethod === 'iterative'" class="d-flex align-items-center" style="gap:8px; white-space:nowrap;">
                                <label class="mode-label" for="rmsdCutoff" style="border:none;">Cutoff (Å)</label>
                                <input id="rmsdCutoff" type="number" min="0.5" max="500" step="0.5" v-model.number="rmsdCutoff" class="form-control" style="width:100px; display:inline-block;">
                                <small class="text-muted" style="font-size:0.85em;">(suggested: 2-300)</small>
                            </div>
                            <div v-if="rmsdMethod === 'iterative'" class="d-flex align-items-center" style="gap:8px; white-space:nowrap;">
                                <label class="mode-label" for="rmsdMaxCycles" style="border:none;">Max Cycles</label>
                                <input id="rmsdMaxCycles" type="number" min="1" max="20" v-model.number="rmsdMaxCycles" class="form-control" style="width:70px; display:inline-block;">
                            </div>
                        </div>
                        <div class="mt-3">
                            <button class="btn-hero btn-hero-primary" @click="calculateRMSD" :disabled="(!(referencePdbContent || useEmbeddedRef) || !(predictedPdbContent || useEmbeddedPred))">
                                <i class="fas fa-calculator"></i> Calculate RMSD
                            </button>
                            <button class="btn-hero btn-hero-white ms-2" @click="loadStructureExampleLow">
                                Load example 1
                            </button>
                            <button class="btn-hero btn-hero-white ms-2" @click="loadStructureExampleHigh">
                                Load example 2
                            </button>
                            <div v-if="rmsdProcessing.active" class="mt-3">
                                <div class="progress" style="height: 8px;">
                                    <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" :style="`width:${rmsdProcessing.value}%`"></div>
                                </div>
                                <small class="text-muted">Calculating... {{ rmsdProcessing.value }}%</small>
                            </div>
                        </div>

                        <div v-if="showRmsdResult" class="mt-4">
                            <div class="alert" :class="rmsdResult.rmsd < 2.0 ? 'alert-success' : 'alert-warning'">
                                <h5><i class="fas fa-check-circle"></i> Structure alignment result</h5>
                                <p v-if="rmsdMethod === 'tmalign' && rmsdResult.tmScore" class="mb-1">
                                    <strong>TM-score:</strong> <span style="font-size: 1.2em; font-weight: bold;">{{ rmsdResult.tmScore.toFixed(4) }}</span>
                                    <span class="ms-2">
                                        <span v-if="rmsdResult.tmScore >= 0.5" class="badge badge-success" style="color:#000 !important;">Similar fold (TM-score ≥ 0.5)</span>
                                        <span v-else class="badge badge-warning" style="color:#000 !important;">Different fold (TM-score &lt; 0.5)</span>
                                    </span>
                                </p>
                                <p class="mb-1"><strong>RMSD:</strong> <span style="font-size: 1.2em; font-weight: bold;">{{ rmsdResult.rmsd.toFixed(3) }} Å</span></p>
                                <p v-if="rmsdResult.alignedAtoms" class="mb-1"><strong>Aligned residues:</strong> {{ rmsdResult.alignedAtoms }} / {{ rmsdResult.totalAtoms || rmsdResult.alignedAtoms }}</p>
                                <p v-if="rmsdResult.cyclesUsed" class="mb-1"><strong>Iterations:</strong> {{ rmsdResult.cyclesUsed }}</p>
                                <p v-if="rmsdMethod !== 'tmalign'" class="mb-0"><strong>Status:</strong> 
                                    <span v-if="rmsdResult.rmsd < 2.0" class="badge badge-success" style="color:#000 !important;">Good structural similarity (RMSD &lt; 2.0 Å)</span>
                                    <span v-else class="badge badge-warning" style="color:#000 !important;">Higher deviation (RMSD ≥ 2.0 Å)</span>
                                </p>
                            </div>
                        </div>

                        <div v-if="rmsdError" class="alert alert-error mt-3">
                            <i class="fas fa-exclamation-triangle"></i> {{ rmsdError }}
                        </div>
                    </div>

                    <h5 class="mt-4">Structural superposition features:</h5>
                    <ul class="mt-3">
                        <li><strong>Kabsch algorithm</strong>: Standard RMSD calculation based on optimal rotation matrix</li>
                        <li><strong>Iterative pruning</strong>: Iteratively remove outliers to improve alignment accuracy</li>
                        <li><strong>TM-align</strong>: Template Modeling score (0-1 scale) for fold similarity assessment. TM-score ≥ 0.5 indicates similar folds</li>
                        <li><strong>Cα atom alignment</strong>: Automatic superposition of Cα atoms for accurate comparison</li>
                        <li><strong>Quality assessment</strong>: RMSD &lt; 2.0 Å or TM-score ≥ 0.5 indicates structural similarity</li>
                    </ul>

                    <div class="alert alert-info mt-4">
                        <i class="fas fa-info-circle"></i>
                        <strong>Note:</strong> This tool calculates the Cα atom RMSD between AlphaFold3 (https://alphafoldserver.com/)-predicted structures and reference structures (original PDB). For more detailed analysis (interface metrics, dG/dSASA, packstat, BUNS), 
                        please use Rosetta tools (https://www.rosettacommons.org/) offline or through the command-line interface. Example files are provided at the bottom of this tool framework.
                    </div>
                </div>
            </section>

            <!-- Documents Section -->
            <section class="section" id="docs">
                <div class="section-header">
                    <h2 class="section-title">
                        <i class="fas fa-book"></i> Documentation
                    </h2>
                </div>
                <div class="section-body">
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <h5><i class="fas fa-file-alt"></i> README</h5>
                            <p>Comprehensive guide covering installation, configuration, and usage of VLPIM.</p>
                            <p><small class="text-muted">Includes quick start guide, prerequisites, and troubleshooting.</small></p>
                            <p class="mt-2">
                                <a href="readme.html" target="_blank" class="btn btn-sm btn-outline-primary">
                                    <i class="fas fa-up-right-from-square"></i> Open README page
                                </a>
                            </p>
                        </div>
                        <div class="col-md-6 mb-3">
                            <h5><i class="fas fa-tools"></i> Tool setup</h5>
                            <p>Usage parameters for ProteinMPNN, NetMHCIIpan, AlphaFold3, and Rosetta wrappers are documented on the dedicated Toolset page.</p>
                            <p class="mt-2">
                                <a href="toolset.html" target="_blank" class="btn btn-sm btn-outline-primary">
                                    <i class="fas fa-up-right-from-square"></i> Open full Toolset page
                                </a>
                            </p>
                        </div>
                        <div class="col-md-6 mb-3">
                            <h5><i class="fas fa-envelope"></i> Contact us</h5>
                            <p>Get help and support from the VLPIM team, Research Center for Medicinal Structural Biology, National Research Center for Translational Medicine at Shanghai, State Key Laboratory of Medical Genomics, Ruijin Hospital, Shanghai Jiao Tong University School of Medicine, Shanghai 200025, China.</p>
                            <p><small class="text-muted">
                                <strong>Email:</strong> wcf231229@163.com<br>
                                <strong>Issues:</strong> <a href="https://github.com/RuijinHospitalVNAR/VLPIM/issues" target="_blank">GitHub Issues</a>
                            </small></p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Cite Us Section -->
            <section class="section" id="cite">
                <div class="section-header">
                    <h2 class="section-title">
                        <i class="fas fa-quote-left"></i> Citation
                    </h2>
                </div>
                <div class="section-body">
                    <p>If you use VLPIM in your research, please cite:</p>
                    <div class="alert alert-info">
                        <pre style="background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>@software{vlpim,
  title={VLPIM: A Comprehensive Tool for Immunogenicity Modulation of Virus-like Particles},
  author={Chufan Wang},
  year={2025},
  url={https://github.com/RuijinHospitalVNAR/VLPIM}
}</code></pre>
                    </div>
                    <h5 class="mt-4">Acknowledgments</h5>
                    <ul class="mt-3">
                        <li><strong>ProteinMPNN</strong> - <a href="https://github.com/dauparas/ProteinMPNN" target="_blank">Sequence generation</a></li>
                        <li><strong>NetMHCIIpan</strong> - <a href="https://services.healthtech.dtu.dk/service.php?NetMHCIIpan-4.0" target="_blank">MHC-II binding prediction</a></li>
                        <li><strong>AlphaFold3</strong> - <a href="https://www.deepmind.com/open-source/alphafold" target="_blank">Structure prediction</a></li>
                        <li><strong>Rosetta</strong> - <a href="https://www.rosettacommons.org/" target="_blank">Interface analysis</a></li>
                    </ul>
                </div>
            </section>
        </div>

        <!-- Footer -->
        <footer class="footer">
            <div class="footer-content">
                <h3>VLPIM</h3>
                <p>A comprehensive tool for immunogenicity modulation of virus-like particles</p>
                <div class="footer-links">
                    <a href="https://github.com/RuijinHospitalVNAR/VLPIM" target="_blank" class="footer-link">
                        <i class="fab fa-github"></i> GitHub
                    </a>
                    <a href="#docs" class="footer-link" @click="scrollTo('docs')">
                        <i class="fas fa-book"></i> Documentation
                    </a>
                    <a href="#cite" class="footer-link" @click="scrollTo('cite')">
                        <i class="fas fa-quote-left"></i> Citation
                    </a>
                </div>
                <div class="mt-3">
                    <small class="text-white-50">
                        <i class="fas fa-eye"></i> Page views: <span id="pageViews">{{ pageViews }}</span>
                    </small>
                </div>
                <p class="mt-4"><small>&copy; 2025 VLPIM. MIT License.</small></p>
            </div>
        </footer>

        <!-- Error Messages -->
        <div v-if="errorMessage" class="main-container">
            <div class="alert alert-error">
                <i class="fas fa-exclamation-triangle"></i> {{ errorMessage }}
            </div>
        </div>
    </div>

    <!-- Optional embedded example structures -->
    <script type="text/plain" id="pdb_6htx">HEADER    DEMO PDB FOR INLINE EXAMPLE
ATOM      1  CA  ALA A   1      11.104  13.207   9.102  1.00 20.00           C
ATOM      2  CA  GLY A   2      12.560  14.890   8.550  1.00 20.00           C
ATOM      3  CA  SER A   3      14.010  16.100   9.900  1.00 20.00           C
ATOM      4  CA  THR A   4      15.400  17.350  11.100  1.00 20.00           C
TER
END
    </script>
    <script type="text/plain" id="pdb_6htx_var">HEADER    DEMO PDB VARIANT FOR INLINE EXAMPLE
ATOM      1  CA  ALA A   1      11.804  13.807   9.602  1.00 20.00           C
ATOM      2  CA  GLY A   2      13.160  15.390   8.950  1.00 20.00           C
ATOM      3  CA  SER A   3      14.610  16.700  10.300  1.00 20.00           C
ATOM      4  CA  THR A   4      16.000  17.850  11.500  1.00 20.00           C
TER
END
    </script>
    <script type="text/plain" id="cif_model_1">data_inline_demo
loop_
 _atom_site.group_PDB
 _atom_site.id
 _atom_site.type_symbol
 _atom_site.label_atom_id
 _atom_site.label_comp_id
 _atom_site.label_asym_id
 _atom_site.label_seq_id
 _atom_site.Cartn_x
 _atom_site.Cartn_y
 _atom_site.Cartn_z
ATOM 1 C CA ALA A 1 11.104 13.207 9.102
ATOM 2 C CA GLY A 2 12.560 14.890 8.550
ATOM 3 C CA SER A 3 14.010 16.100 9.900
ATOM 4 C CA THR A 4 15.400 17.350 11.100
    </script>
    <script type="text/plain" id="pdb_6htx_far">HEADER    DEMO PDB FAR VARIANT FOR INLINE EXAMPLE
ATOM      1  CA  ALA A   1      41.104  43.207  39.102  1.00 20.00           C
ATOM      2  CA  GLY A   2      52.560  54.890  38.550  1.00 20.00           C
ATOM      3  CA  SER A   3      64.010  66.100  39.900  1.00 20.00           C
ATOM      4  CA  THR A   4      75.400  77.350  41.100  1.00 20.00           C
TER
END
    </script>

    <script type="text/plain" id="example_netmhcii_data">
				HLA-DPA10103-DPB10101							HLA-DPA10103-DPB10201							HLA-DPA10103-DPB10301							HLA-DPA10103-DPB10401							HLA-DPA10103-DPB10402							HLA-DPA10103-DPB10501							HLA-DPA10103-DPB10601							HLA-DPA10103-DPB11001							HLA-DPA10103-DPB11101								
Pos	Peptide	ID	Target	Core	Inverted	Score	Rank	Score_BA	nM	Rank_BA	Core	Inverted	Score	Rank	Score_BA	nM	Rank_BA	Core	Inverted	Score	Rank	Score_BA	nM	Rank_BA	Core	Inverted	Score	Rank	Score_BA	nM	Rank_BA	Core	Inverted	Score	Rank	Score_BA	nM	Rank_BA	Core	Inverted	Score	Rank	Score_BA	nM	Rank_BA	Core	Inverted	Score	Rank	Score_BA	nM	Rank_BA	Core	Inverted	Score	Rank	Score_BA	nM	Rank_BA	Core	Inverted	Score	Rank	Score_BA	nM	Rank_BA	Ave	NB
1	MDIDPYKEFGATVEL	Sequence	NA	PYKEFGATV	0	0.006287	46.111362	0.244696	3541.197754	58.410503	IDPYKEFGA	0	0.001446	46.024883	0.220514	4600.240234	53.091480	YKEFGATVE	0	0.000409	64.749916	0.129688	12290.572266	68.313454	YKEFGATVE	0	0.003218	25.511967	0.178860	7219.565430	54.345913	PYKEFGATV	0	0.000900	50.485016	0.138562	11165.349609	60.385944	PYKEFGATV	0	0.005831	43.878105	0.165638	8329.983398	64.029945	YKEFGATVE	0	0.000715	64.670746	0.161040	8754.872070	63.493389	KEFGATVEL	0	0.000439	68.996048	0.145470	10361.203125	55.000343	YKEFGATVE	0	0.008075	23.702341	0.179634	7159.369629	63.334003	0.003036	     0
2	DIDPYKEFGATVELL	Sequence	NA	KEFGATVEL	0	0.007303	43.492126	0.313269	1686.283203	40.372917	YKEFGATVE	0	0.000449	65.213234	0.287989	2216.746338	36.936604	YKEFGATVE	0	0.000886	53.773834	0.184139	6818.756348	49.521042	YKEFGATVE	0	0.003159	25.728050	0.229098	4192.218262	40.879551	YKEFGATVE	0	0.000754	53.365612	0.185400	6726.355469	44.907333	KEFGATVEL	0	0.003097	55.694717	0.223143	4471.258789	46.462128	YKEFGATVE	0	0.001462	54.035400	0.238538	3785.193604	39.450390	KEFGATVEL	0	0.006757	30.776024	0.221800	4536.702148	29.543497	YKEFGATVE	0	0.010748	20.629946	0.245364	3515.711914	44.758705	0.003846	     0
3	IDPYKEFGATVELLS	Sequence	NA	YKEFGATVE	0	0.010311	37.548119	0.382965	793.281677	24.460529	YKEFGATVE	0	0.000676	58.590431	0.333670	1352.275391	28.189098	KEFGATVEL	0	0.002315	40.487015	0.233926	3978.873779	35.370163	YKEFGATVE	0	0.004178	22.530519	0.311810	1713.112061	24.424974	YKEFGATVE	0	0.001238	45.649521	0.261660	2947.386230	25.850580	KEFGATVEL	0	0.002917	56.879047	0.277320	2488.019287	31.955809	YKEFGATVE	0	0.003400	41.629120	0.292191	2118.235596	26.261055	KEFGATVEL	0	0.022479	17.574270	0.262459	2922.025391	20.128113	YKEFGATVE	0	0.017622	15.865467	0.332583	1368.278076	24.843374	0.007237	     0
4	DPYKEFGATVELLSF	Sequence	NA	KEFGATVEL	0	0.008217	41.474422	0.444504	407.622711	13.992314	YKEFGATVE	0	0.000571	61.352501	0.406372	615.798645	17.008368	KEFGATVEL	0	0.002187	41.206161	0.274917	2553.548340	26.233192	YKEFGATVE	0	0.002865	26.866348	0.401924	646.160706	12.777327	FGATVELLS	0	0.003776	30.092564	0.334165	1345.048584	14.139259	KEFGATVEL	0	0.003143	55.391949	0.329873	1408.990112	20.680183	KEFGATVEL	0	0.002337	47.019005	0.340073	1261.767822	17.374313	KEFGATVEL	0	0.026281	16.153793	0.299795	1950.927002	13.668566	YKEFGATVE	0	0.006264	26.578455	0.381696	804.252808	16.485132	0.006182	     0
5	PYKEFGATVELLSFL	Sequence	NA	EFGATVELL	0	0.005837	47.465378	0.463309	332.579315	11.495481	FGATVELLS	0	0.000503	63.471977	0.442770	415.344208	12.800470	FGATVELLS	0	0.001077	50.898880	0.299233	1962.832764	21.735506	FGATVELLS	0	0.001497	35.229431	0.436696	443.556458	9.689247	FGATVELLS	0	0.005136	26.413551	0.381380	807.005432	9.210913	FGATVELLS	0	0.002933	56.778038	0.356048	1061.477783	16.241293	EFGATVELL	0	0.000747	64.079155	0.363200	982.438721	13.881778	EFGATVELL	0	0.008250	28.359158	0.310016	1746.675659	12.205329	EFGATVELL	0	0.002239	39.881912	0.407900	605.705322	13.033431	0.003135	     0
6	YKEFGATVELLSFLP	Sequence	NA	GATVELLSF	0	0.009006	39.863316	0.470076	309.097870	10.671485	FGATVELLS	0	0.001210	48.893394	0.453771	368.733734	11.707919	FGATVELLS	0	0.001605	45.323086	0.301545	1914.347046	21.330593	FGATVELLS	0	0.004623	21.463249	0.445421	403.600128	9.050409	FGATVELLS	0	0.013488	16.420563	0.394315	701.611572	8.145961	FGATVELLS	0	0.006348	42.356377	0.361885	996.519287	15.374006	FGATVELLS	0	0.000477	70.622261	0.360205	1014.789917	14.287660	EFGATVELL	0	0.000771	61.041416	0.288980	2193.124512	15.381474	FGATVELLS	0	0.001274	48.044945	0.406866	612.516724	13.164658	0.004311	     0
7	KEFGATVELLSFLPS	Sequence	NA	GATVELLSF	0	0.013913	32.426743	0.539193	146.325043	4.542799	VELLSFLPS	0	0.001002	52.152039	0.508457	204.054321	7.268163	FGATVELLS	0	0.000521	61.417988	0.285473	2277.936279	24.210777	VELLSFLPS	0	0.005326	20.031754	0.499080	225.842865	5.748776	VELLSFLPS	0	0.008857	20.406153	0.450091	383.711700	4.697382	GATVELLSF	0	0.006967	40.604435	0.360245	1014.355469	15.615196	FGATVELLS	0	0.000159	84.077431	0.358849	1029.794922	14.476208	GATVELLSF	0	0.000212	78.354134	0.256954	3101.348145	21.264183	TVELLSFLP	0	0.000686	57.336391	0.449788	384.974091	8.565031	0.004183	     0
8	EFGATVELLSFLPSD	Sequence	NA	VELLSFLPS	0	0.037312	18.087740	0.536237	151.080307	4.725594	VELLSFLPS	0	0.017132	15.060800	0.507138	206.988098	7.358927	VELLSFLPS	0	0.000864	54.108860	0.258362	3054.464111	29.679203	VELLSFLPS	0	0.031912	7.274711	0.483176	268.251526	6.581336	VELLSFLPS	0	0.121904	4.341625	0.455948	360.149353	4.423702	VELLSFLPS	0	0.025064	19.684116	0.340590	1254.724487	18.710514	VELLSFLPS	0	0.000342	75.023865	0.328740	1426.370239	19.269951	VELLSFLPS	0	0.000401	70.106972	0.210450	5129.484863	32.666588	VELLSFLPS	0	0.007751	24.155956	0.432319	465.065460	10.274512	0.026965	     1
9	FGATVELLSFLPSDF	Sequence	NA	VELLSFLPS	0	0.039796	17.307194	0.564941	110.745872	3.147976	VELLSFLPS	0	0.033637	10.254067	0.554719	123.697227	4.611399	VELLSFLPS	0	0.001412	47.049057	0.273795	2584.718262	26.443031	VELLSFLPS	0	0.035624	6.814987	0.530047	161.545670	4.341010	VELLSFLPS	0	0.186385	3.208308	0.483072	268.552368	3.348881	VELLSFLPS	0	0.028190	18.168308	0.374333	870.944824	13.571951	VELLSFLPS	0	0.000597	67.486206	0.368288	929.812866	13.231267	VELLSFLPS	0	0.000747	61.536793	0.241233	3676.419678	24.788599	VELLSFLPS	0	0.010518	20.844416	0.465793	323.760803	7.187905	0.037434	     1
10	GATVELLSFLPSDFF	Sequence	NA	VELLSFLPS	0	0.036020	18.521545	0.583402	90.694344	2.369654	VELLSFLPS	0	0.028263	11.345924	0.591666	82.937027	2.987531	VELLSFLPS	0	0.001430	46.878094	0.293703	2083.850830	22.714344	VELLSFLPS	0	0.025382	8.326552	0.565367	110.237457	3.138052	VELLSFLPS	0	0.168142	3.473072	0.515882	188.301559	2.315645	VELLSFLPS	0	0.025134	19.648540	0.396416	685.843506	10.695029	VELLSFLPS	0	0.000847	62.266109	0.405400	622.311646	8.943659	VELLSFLPS	0	0.000771	61.037086	0.271968	2636.331055	18.297230	VELLSFLPS	0	0.008916	22.588997	0.500709	221.899033	4.692415	0.032767	     1
    </script>
    <script>
        new Vue({
            el: '#app',
            data: {
                currentSection: 'home',
                errorMessage: '',
                analysisMode: 'enhance',
                epitopeMode: 'enhance',
                peptideRows: [],
                peptideSortBy: 'overall',
                referencePdbContent: '',
                predictedPdbContent: '',
                referenceFileName: '',
                predictedFileName: '',
                    referenceFileObj: null,
                    predictedFileObj: null,
                isNetmhciiLoading: false,
                isCsvLoading: false,
                isRefLoading: false,
                isPredLoading: false,
                rmsdResult: null,
                rmsdError: '',
                netmhciiFileName: '',
                netmhciiFileContent: '',
                    epitopeRows: [],
                    peptideLength: 15,
                epitopeLength: 15,
                fastaFileName: '',
                fastaText: '',
                vlpSequenceText: '',
                vlpSequenceLength: 0,
                vlpSequenceError: '',
                epitopesNumber: 10,
                advancedEpitopes: [],
                wy2Mode: 'reduce',
                wy2CsvName: '',
                wy2CsvText: '',
                wy2Peptides: [],
                wy2Seqsum: [],
                // Page view counter
                pageViews: 0,
                // Progress indicators
                wy2Processing: { active: false, value: 0 },
                epitopeProcessing: { active: false, value: 0 },
                rmsdProcessing: { active: false, value: 0 },
                _wy2Timer: null,
                _epiTimer: null,
                _rmsdTimer: null,
                showRmsdResult: false,
                // Iterative alignment parameters
                rmsdMethod: 'kabsch', // 'kabsch', 'iterative', or 'tmalign'
                rmsdCutoff: 2.0, // Cutoff for iterative pruning (Angstroms)
                rmsdMaxCycles: 5, // Maximum cycles for iterative alignment
                // Embedded example control (structure-only lazy load)
                useEmbeddedRef: false,
                useEmbeddedPred: false,
                embeddedRefId: '',
                embeddedPredId: ''
            },
            computed: {
                sortedPeptides() {
                    const base = (this.wy2Peptides && this.wy2Peptides.length) ? this.wy2Peptides : this.peptideRows;
                    const rows = [...base];
                    if (!rows.length) return rows;
                    // Default sort: by mode (reduce: ascending, enhance: descending)
                    let sorted = rows;
                    switch (this.peptideSortBy) {
                        case 'ic50':
                            sorted = rows.sort((a,b)=> Number(a.Best_IC50 || a['Best_IC50(nM)'] || Infinity) - Number(b.Best_IC50 || b['Best_IC50(nM)'] || Infinity));
                            break;
                        case 'alleles':
                            sorted = rows.sort((a,b)=> Number(b.Allele_Count || b.Alleles || 0) - Number(a.Allele_Count || a.Alleles || 0));
                            break;
                        case 'overall':
                        default:
                            // Sort by mode: reduce (lower is better), enhance (higher is better)
                            if (this.wy2Mode && rows[0] && rows[0].Overall !== undefined) {
                                sorted = rows.sort((a,b)=> this.wy2Mode==='reduce' ? (Number(a.Overall) - Number(b.Overall)) : (Number(b.Overall) - Number(a.Overall)));
                            } else {
                                sorted = rows.sort((a,b)=> Number(a.Overall || 0) - Number(b.Overall || 0));
                            }
                            break;
                    }
                    // Reassign rank after sorting
                    sorted.forEach((r, idx) => { r.Rank = idx + 1; });
                    return sorted;
                }
            },
            methods: {
                initPageViews() {
                    // Use localStorage and sessionStorage to track page views (client-side only)
                    // For server-side tracking, you would need a backend service
                    const storageKey = 'vlpim_page_views';
                    const sessionKey = 'vlpim_session';
                    
                    try {
                        // Check if this is a new session (not a page refresh)
                        const sessionId = sessionStorage.getItem(sessionKey);
                        let views = parseInt(localStorage.getItem(storageKey) || '0', 10);
                        
                        if (!sessionId) {
                            // New session - increment view count
                            sessionStorage.setItem(sessionKey, Date.now().toString());
                            views += 1;
                            localStorage.setItem(storageKey, views.toString());
                        }
                        
                        this.pageViews = views;
                    } catch (e) {
                        console.warn('Page view counter initialization failed:', e);
                        this.pageViews = 0;
                    }
                },
                getEmbeddedText(id) {
                    const el = document.getElementById(id);
                    return el ? (el.textContent || '').trim() : '';
                },
                scrollTo(section) {
                    this.currentSection = section;
                    const el = document.getElementById(section);
                    if (el) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                },
                scoreClass(val) {
                    const v = Number(val);
                    if (Number.isNaN(v)) return 'score-low';
                    if (v < 40) return 'score-high';
                    if (v < 70) return 'score-medium';
                    return 'score-low';
                },
                handleNetMHCIIUpload(evt) {
                    try {
                        const file = evt.target.files[0];
                        if (!file) return;
                        this.netmhciiFileName = file.name;
                        this.errorMessage = '';
                        
                        // Check file extension
                        const fileName = file.name.toLowerCase();
                        if (fileName.endsWith('.txt')) {
                            // Handle text file
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                const content = e.target.result || '';
                                this.netmhciiFileContent = content;
                                this.epitopeRows = [];
                                this.errorMessage = '';
                            };
                            reader.readAsText(file, 'utf-8');
                        } else if (fileName.endsWith('.xls') || fileName.endsWith('.xlsx')) {
                            // Handle Excel file
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                try {
                                    const data = new Uint8Array(e.target.result);
                                    const workbook = XLSX.read(data, { type: 'array' });
                                    
                                    // Convert Excel to text format (NetMHCIIpan format)
                                    const textContent = this.convertExcelToNetMHCIIFormat(workbook);
                                    if (textContent) {
                                        this.netmhciiFileContent = textContent;
                                        this.epitopeRows = [];
                                        this.errorMessage = '';
                                    } else {
                                        this.errorMessage = 'Failed to parse Excel file. Please check the file format.';
                                    }
                                } catch (excelError) {
                                    console.error('Excel parsing error:', excelError);
                                    this.errorMessage = 'Failed to parse Excel file: ' + (excelError.message || 'Unknown error');
                                }
                            };
                            reader.readAsArrayBuffer(file);
                        } else {
                            this.errorMessage = 'Unsupported file format. Please use .txt, .xls, or .xlsx files.';
                        }
                    } catch (e) {
                        this.errorMessage = e.message || 'File read failed';
                    }
                },
                convertExcelToNetMHCIIFormat(workbook) {
                    // NetMHCIIpan Excel format typically has:
                    // Row 1: Header with allele names (Pos, Peptide, ID, Target, then HLA alleles)
                    // Row 2: Field names (empty for Pos/Peptide/ID/Target, then Core, Inverted, Score, Rank, Score_BA, nM, Rank_BA for each HLA)
                    // Row 3+: Data rows
                    
                    try {
                        // Get the first sheet
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        
                        // Convert to JSON format with raw values (preserve numbers as numbers)
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
                            header: 1, 
                            defval: '',
                            raw: false  // Convert to strings for consistency
                        });
                        
                        if (!jsonData || jsonData.length < 2) {
                            console.error('Excel file has insufficient rows');
                            return null;
                        }
                        
                        // Build text format (tab-separated) similar to NetMHCIIpan standard output
                        const lines = [];
                        
                        // Process each row
                        for (let i = 0; i < jsonData.length; i++) {
                            const row = jsonData[i] || [];
                            
                            // Convert row to array of strings, handling empty cells
                            const processedRow = [];
                            for (let j = 0; j < row.length; j++) {
                                const cell = row[j];
                                if (cell === null || cell === undefined) {
                                    processedRow.push('');
                                } else if (typeof cell === 'number') {
                                    // Keep numbers as-is for proper parsing later
                                    processedRow.push(cell.toString());
                                } else {
                                    processedRow.push(String(cell).trim());
                                }
                            }
                            
                            // Only add non-empty rows
                            if (processedRow.length > 0 && processedRow.some(cell => cell !== '')) {
                                lines.push(processedRow.join('\t'));
                            }
                        }
                        
                        if (lines.length < 2) {
                            console.error('Excel file has insufficient data rows');
                            return null;
                        }
                        
                        console.log(`Converted Excel file: ${lines.length} rows`);
                        return lines.join('\n');
                    } catch (error) {
                        console.error('Error converting Excel to text:', error);
                        console.error('Error stack:', error.stack);
                        return null;
                    }
                },
                parseNetMHCIIFile() {
                    if (!this.netmhciiFileContent) {
                        this.errorMessage = 'Please upload a NetMHCIIpan file first.';
                        return;
                    }
                    try {
                        this.errorMessage = '';
                        const lines = this.netmhciiFileContent.split('\n');
                        const rows = [];
                        
                        let headerFound = false;
                        let headerLine = -1;
                        
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();
                            if (!line || line.startsWith('#')) continue;
                            
                            if (line.includes('Pos') && line.includes('Peptide') && line.includes('Allele')) {
                                headerFound = true;
                                headerLine = i;
                                continue;
                            }
                            
                            if (headerFound && i > headerLine) {
                                let parts;
                                if (line.includes('\t')) {
                                    parts = line.split('\t').map(p => p.trim()).filter(p => p.length > 0);
                                } else {
                                    parts = line.split(/\s+/).filter(p => p.length > 0);
                                }
                                
                                if (parts.length >= 6) {
                                    const pos = parts[0];
                                    const peptide = parts[1];
                                    let allele = parts[2] || parts[3] || '-';
                                    let ic50 = null;
                                    let rank = null;
                                    
                                    for (let j = 3; j < parts.length; j++) {
                                        const val = parts[j];
                                        const num = parseFloat(val);
                                        
                                        if (!isNaN(num)) {
                                            if (num > 1 && num < 100000 && !ic50) {
                                                ic50 = num;
                                            } else if (num >= 0 && num <= 100 && !rank) {
                                                rank = num;
                                            }
                                        }
                                    }
                                    
                                    if (peptide && peptide.length >= 5) {
                                        rows.push({
                                            Peptide: peptide,
                                            Allele: allele,
                                            'BA_IC50': ic50 || '-',
                                            Rank: rank || '-',
                                            Pos: pos || '-'
                                        });
                                    }
                                }
                            }
                        }
                        
                        if (rows.length === 0) {
                            this.errorMessage = 'No epitopes found in the file. Please check the file format.';
                            return;
                        }

                        const filtered = Array.isArray(rows)
                            ? rows.filter(r => (r.Peptide || r.peptide || '').length === Number(this.peptideLength))
                            : [];

                        if (filtered.length === 0) {
                            this.errorMessage = 'No epitopes match the selected peptide length.';
                        }

                        this.epitopeRows = filtered.length ? filtered : [];
                        this.scrollTo('epitope');
                    } catch (e) {
                        this.errorMessage = 'Failed to parse NetMHCIIpan file: ' + (e.message || 'Unknown error');
                        this.epitopeRows = [];
                    }
                },
                exportEpitopes() {
                    if (!this.epitopeRows || !this.epitopeRows.length) return;
                    try {
                        const header = ['Peptide', 'Allele', 'IC50(nM)', 'Rank(%)', 'Position'];
                        const rows = this.epitopeRows.map(r => [
                            r.Peptide || r.peptide || '',
                            r.Allele || r.allele || '',
                            r['BA_IC50'] || r.IC50 || r.ic50 || '',
                            r.Rank || r.rank || '',
                            r.Pos || r.pos || ''
                        ]);
                        const csv = [header.join(','), ...rows.map(x => x.join(','))].join('\n');
                        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'epitopes.csv';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        this.errorMessage = e.message || 'Export failed';
                    }
                },
                handlePdbUpload(type, evt) {
                    try {
                        const file = evt.target.files[0];
                        if (!file) return;
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const text = e.target.result || '';
                            if (type === 'reference') {
                                this.referencePdbContent = text;
                                this.referenceFileName = file.name;
                                this.referenceFileObj = file;
                            } else if (type === 'predicted') {
                                this.predictedPdbContent = text;
                                this.predictedFileName = file.name;
                                this.predictedFileObj = file;
                            }
                            this.rmsdResult = null;
                            this.rmsdError = '';
                            this.showRmsdResult = false;
                        };
                        reader.readAsText(file, 'utf-8');
                    } catch (e) {
                        this.rmsdError = e.message || 'File read failed';
                    }
                },
                parsePDB(pdbText) {
                    const lines = pdbText.split('\n');
                    const caAtoms = [];
                    for (const line of lines) {
                        if (line.startsWith('ATOM') || line.startsWith('HETATM')) {
                            const record = line.substring(0, 6).trim();
                            const atomName = line.substring(12, 16).trim();
                            if (atomName === 'CA') {
                                try {
                                    const x = parseFloat(line.substring(30, 38));
                                    const y = parseFloat(line.substring(38, 46));
                                    const z = parseFloat(line.substring(46, 54));
                                    if (!Number.isNaN(x) && !Number.isNaN(y) && !Number.isNaN(z)) {
                                        caAtoms.push([x, y, z]);
                                    }
                                } catch (e) {
                                    continue;
                                }
                            }
                        }
                    }
                    return caAtoms;
                },
                centerCoordinates(coords) {
                    if (coords.length === 0) return coords;
                    const n = coords.length;
                    let sumX = 0, sumY = 0, sumZ = 0;
                    for (const [x, y, z] of coords) {
                        sumX += x;
                        sumY += y;
                        sumZ += z;
                    }
                    const centerX = sumX / n;
                    const centerY = sumY / n;
                    const centerZ = sumZ / n;
                    return coords.map(([x, y, z]) => [x - centerX, y - centerY, z - centerZ]);
                },
                // Helper: Calculate R and t from two coordinate sets (matching Python kabsch_algorithm)
                // Use exact same logic as kabschAlign to ensure consistency
                kabschAlgorithm(pCoords, qCoords) {
                    const n = pCoords.length;
                    if (n !== qCoords.length || n < 3) return null;
                    
                    // Use centerCoordinates (same as kabschAlign)
                    const P = this.centerCoordinates(pCoords);
                    const Q = this.centerCoordinates(qCoords);
                    
                    // Compute covariance matrix H = P^T @ Q (same as kabschAlign)
                    const H = [[0,0,0],[0,0,0],[0,0,0]];
                    for (let i=0;i<n;i++) {
                        const [px,py,pz]=P[i]; const [qx,qy,qz]=Q[i];
                        H[0][0]+=px*qx; H[0][1]+=px*qy; H[0][2]+=px*qz;
                        H[1][0]+=py*qx; H[1][1]+=py*qy; H[1][2]+=py*qz;
                        H[2][0]+=pz*qx; H[2][1]+=pz*qy; H[2][2]+=pz*qz;
                    }
                    
                    // SVD calculation (exact same as kabschAlign to ensure consistency)
                    // IMPORTANT: Force use of external SVD library if available, as svd3x3 may have issues
                    let svdResult = null;
                    let usedExternal = false;
                    try {
                        // Try external SVD library first (same as kabschAlign)
                        if (typeof SVDJS !== 'undefined' && typeof SVDJS.SVD === 'function') {
                            svdResult = SVDJS.SVD(H);
                            usedExternal = true;
                        } else if (typeof window !== 'undefined' && window.SVDJS && typeof window.SVDJS.SVD === 'function') {
                            svdResult = window.SVDJS.SVD(H);
                            usedExternal = true;
                        } else if (typeof window !== 'undefined' && window.SVD) {
                            if (typeof window.SVD.SVD === 'function') {
                                svdResult = window.SVD.SVD(H);
                                usedExternal = true;
                            } else if (typeof window.SVD === 'function') {
                                svdResult = window.SVD(H);
                                usedExternal = true;
                            }
                        } else if (typeof SVD !== 'undefined') {
                            if (typeof SVD.SVD === 'function') {
                                svdResult = SVD.SVD(H);
                                usedExternal = true;
                            } else if (typeof SVD === 'function') {
                                svdResult = SVD(H);
                                usedExternal = true;
                            }
                        }
                        
                        // Fallback to built-in SVD for 3x3 matrix (same as kabschAlign)
                        if (!svdResult || !svdResult.u || !svdResult.v) {
                            svdResult = this.svd3x3(H);
                            usedExternal = false;
                        }
                    } catch (e) {
                        console.warn('External SVD library failed, using built-in implementation:', e);
                        // Fallback to built-in SVD (same as kabschAlign)
                        svdResult = this.svd3x3(H);
                        usedExternal = false;
                    }
                    
                    // Debug log (only in iterative alignment cycle 0)
                    if (typeof this._iterativeCycle === 'undefined') {
                        this._iterativeCycle = 0;
                    }
                    if (this._iterativeCycle === 0 && !usedExternal) {
                        console.warn('kabschAlgorithm: Using svd3x3 (internal implementation). R matrix determinant may be incorrect.');
                    }
                    
                    if (!svdResult || !svdResult.u || !svdResult.v) {
                        return null;
                    }
                    
                    // R calculation (matching Python: R = Vt.T @ U.T)
                    // Python's np.linalg.svd returns U, S, Vt where Vt is V^T (V transposed)
                    // So Python: R = Vt.T @ U.T = V @ U.T
                    // For svd3x3, we return {u: U, v: V} where V is column-major (eigenvectors as columns)
                    // So we need R = V @ U.T (not Vt @ Ut!)
                    // But for external SVD libraries, they may return V differently
                    const U = svdResult.u, V = svdResult.v;
                    const Ut = [[U[0][0],U[1][0],U[2][0]],[U[0][1],U[1][1],U[2][1]],[U[0][2],U[1][2],U[2][2]]];
                    
                    // Check if we're using svd3x3 (internal) or external library
                    // svd3x3 returns V as column-major, so we need R = V @ Ut
                    // External libraries may return V differently, so try both
                    let R1 = this.mul3(V, Ut); // R = V @ U.T (for svd3x3)
                    const Vt = [[V[0][0],V[1][0],V[2][0]],[V[0][1],V[1][1],V[2][1]],[V[0][2],V[1][2],V[2][2]]];
                    let R2 = this.mul3(Vt, Ut); // R = V^T @ U.T (for external libraries)
                    
                    // Use the one with determinant closer to 1.0
                    const det1 = this.det3(R1);
                    const det2 = this.det3(R2);
                    let R = (Math.abs(det1 - 1.0) < Math.abs(det2 - 1.0)) ? R1 : R2;
                    
                    // Ensure proper rotation (det(R) = 1) - matching Python: Vt[-1, :] *= -1 then recalculate
                    const detBefore = this.det3(R);
                    if (detBefore < 0) {
                        // Modify last column of V (matching Python Vt[-1, :] *= -1)
                        V[0][2]*=-1; V[1][2]*=-1; V[2][2]*=-1;
                        // Recalculate both formulations
                        R1 = this.mul3(V, Ut);
                        const Vt2 = [[V[0][0],V[1][0],V[2][0]],[V[0][1],V[1][1],V[2][1]],[V[0][2],V[1][2],V[2][2]]];
                        R2 = this.mul3(Vt2, Ut);
                        const det1Fixed = this.det3(R1);
                        const det2Fixed = this.det3(R2);
                        R = (Math.abs(det1Fixed - 1.0) < Math.abs(det2Fixed - 1.0)) ? R1 : R2;
                    }
                    
                    // Translation vector: t = mean(Q) - R * mean(P) (same as kabschAlign)
                    const meanP = this.mean3(pCoords); const meanQ = this.mean3(qCoords);
                    const Rp = this.mul3vec(R, meanP);
                    const t = [meanQ[0]-Rp[0], meanQ[1]-Rp[1], meanQ[2]-Rp[2]];
                    
                    return { R, t };
                },
                kabschAlign(pCoords, qCoords) {
                    const n = pCoords.length;
                    if (n !== qCoords.length || n < 3) return null;
                    const P = this.centerCoordinates(pCoords);
                    const Q = this.centerCoordinates(qCoords);
                    const H = [[0,0,0],[0,0,0],[0,0,0]];
                    for (let i=0;i<n;i++) {
                        const [px,py,pz]=P[i]; const [qx,qy,qz]=Q[i];
                        H[0][0]+=px*qx; H[0][1]+=px*qy; H[0][2]+=px*qz;
                        H[1][0]+=py*qx; H[1][1]+=py*qy; H[1][2]+=py*qz;
                        H[2][0]+=pz*qx; H[2][1]+=pz*qy; H[2][2]+=pz*qz;
                    }
                    // SVD calculation: try external library first, then fallback to built-in implementation
                    let svdResult = null;
                    try {
                        // Try external SVD library first
                        if (typeof SVDJS !== 'undefined' && typeof SVDJS.SVD === 'function') {
                            svdResult = SVDJS.SVD(H);
                        } else if (typeof window !== 'undefined' && window.SVDJS && typeof window.SVDJS.SVD === 'function') {
                            svdResult = window.SVDJS.SVD(H);
                        } else if (typeof window !== 'undefined' && window.SVD) {
                            if (typeof window.SVD.SVD === 'function') {
                                svdResult = window.SVD.SVD(H);
                            } else if (typeof window.SVD === 'function') {
                                svdResult = window.SVD(H);
                            }
                        } else if (typeof SVD !== 'undefined') {
                            if (typeof SVD.SVD === 'function') {
                                svdResult = SVD.SVD(H);
                            } else if (typeof SVD === 'function') {
                                svdResult = SVD(H);
                            }
                        }
                        
                        // Fallback to built-in SVD for 3x3 matrix
                        if (!svdResult || !svdResult.u || !svdResult.v) {
                            svdResult = this.svd3x3(H);
                        }
                    } catch (e) {
                        console.warn('External SVD library failed, using built-in implementation:', e);
                        // Fallback to built-in SVD
                        svdResult = this.svd3x3(H);
                    }
                    
                    if (!svdResult || !svdResult.u || !svdResult.v) {
                        console.error('SVD calculation failed completely. H matrix:', H);
                        return null;
                    }
                    const U = svdResult.u, V = svdResult.v;
                    // Python: R = Vt.T @ U.T where Vt from SVD is V^T
                    // JavaScript SVD returns {u: U, v: V} where V is V itself
                    // So R = V^T @ U^T
                    const Ut = [[U[0][0],U[1][0],U[2][0]],[U[0][1],U[1][1],U[2][1]],[U[0][2],U[1][2],U[2][2]]];
                    const Vt = [[V[0][0],V[1][0],V[2][0]],[V[0][1],V[1][1],V[2][1]],[V[0][2],V[1][2],V[2][2]]];
                    let R = this.mul3(Vt, Ut);
                    if (this.det3(R) < 0) { 
                        V[0][2]*=-1; V[1][2]*=-1; V[2][2]*=-1;
                        const Vt2 = [[V[0][0],V[1][0],V[2][0]],[V[0][1],V[1][1],V[2][1]],[V[0][2],V[1][2],V[2][2]]];
                        R = this.mul3(Vt2, Ut);
                    }
                    const meanP = this.mean3(pCoords); const meanQ = this.mean3(qCoords);
                    const Rp = this.mul3vec(R, meanP);
                    const t = [meanQ[0]-Rp[0], meanQ[1]-Rp[1], meanQ[2]-Rp[2]];
                    // Apply transformation to original (non-centered) coordinates
                    // aligned = R @ pCoords + t (matching Python: (R @ coords.T).T + t)
                    const aligned = pCoords.map(([x,y,z])=>{ 
                        const v = this.mul3vec(R, [x,y,z]);
                        return [v[0]+t[0], v[1]+t[1], v[2]+t[2]];
                    });
                    // Return original coordinates for RMSD calculation (matching Python)
                    return { refCoords: qCoords, alignedCoords: aligned };
                },
                det3(M){
                    return M[0][0]*(M[1][1]*M[2][2]-M[1][2]*M[2][1]) - M[0][1]*(M[1][0]*M[2][2]-M[1][2]*M[2][0]) + M[0][2]*(M[1][0]*M[2][1]-M[1][1]*M[2][0]);
                },
                mul3(A,B){
                    const C=[[0,0,0],[0,0,0],[0,0,0]];
                    for(let i=0;i<3;i++) for(let j=0;j<3;j++) C[i][j]=A[i][0]*B[0][j]+A[i][1]*B[1][j]+A[i][2]*B[2][j];
                    return C;
                },
                mul3vec(A,v){
                    return [A[0][0]*v[0]+A[0][1]*v[1]+A[0][2]*v[2], A[1][0]*v[0]+A[1][1]*v[1]+A[1][2]*v[2], A[2][0]*v[0]+A[2][1]*v[1]+A[2][2]*v[2]];
                },
                mean3(coords){
                    const n=coords.length; let sx=0,sy=0,sz=0; for(const [x,y,z] of coords){ sx+=x; sy+=y; sz+=z; } return [sx/n, sy/n, sz/n];
                },
                // Built-in SVD for 3x3 matrix (for Kabsch algorithm)
                // Uses a direct implementation for 3x3 matrices
                svd3x3(H) {
                    try {
                        // Direct SVD implementation for 3x3 matrix
                        // Python: U, S, Vt = np.linalg.svd(H) where Vt is V^T (row-major)
                        // We return {u: U, v: V} where V is column-major (eigenvectors as columns)
                        
                        // Compute H^T @ H and H @ H^T for SVD
                        const Ht = this.transpose3(H);
                        const HtH = this.mul3(Ht, H);  // H^T @ H (3x3 symmetric)
                        const HHt = this.mul3(H, Ht);  // H @ H^T (3x3 symmetric)
                        
                        // Compute eigenvalues and eigenvectors of H^T @ H (gives V)
                        const eigenV = this.jacobi3x3(HtH);
                        if (!eigenV || !eigenV.values || !eigenV.vectors) {
                            return null;
                        }
                        
                        // Compute eigenvalues and eigenvectors of H @ H^T (gives U)
                        const eigenU = this.jacobi3x3(HHt);
                        if (!eigenU || !eigenU.values || !eigenU.vectors) {
                            return null;
                        }
                        
                        // Sort by eigenvalues descending (for both)
                        const indicesV = [0, 1, 2].sort((a, b) => eigenV.values[b] - eigenV.values[a]);
                        const indicesU = [0, 1, 2].sort((a, b) => eigenU.values[b] - eigenU.values[a]);
                        
                        // Build V (right singular vectors as columns)
                        // V[j][i] = j-th component of i-th eigenvector of H^T @ H
                        const V = [[0,0,0],[0,0,0],[0,0,0]];
                        const sigma = [0,0,0];
                        for (let i = 0; i < 3; i++) {
                            const idx = indicesV[i];
                            const eigenval = Math.max(0, eigenV.values[idx]);
                            sigma[i] = Math.sqrt(eigenval);
                            // eigenV.vectors[idx] is [vx, vy, vz] (row-major)
                            // V[j][i] = j-th component of i-th eigenvector
                            for (let j = 0; j < 3; j++) {
                                V[j][i] = eigenV.vectors[idx][j];
                            }
                        }
                        
                        // Build U (left singular vectors as columns)
                        // U[j][i] = j-th component of i-th eigenvector of H @ H^T
                        const U = [[0,0,0],[0,0,0],[0,0,0]];
                        for (let i = 0; i < 3; i++) {
                            const idx = indicesU[i];
                            // eigenU.vectors[idx] is [ux, uy, uz] (row-major)
                            // U[j][i] = j-th component of i-th eigenvector
                            for (let j = 0; j < 3; j++) {
                                U[j][i] = eigenU.vectors[idx][j];
                            }
                        }
                        
                        // Ensure U and V have correct signs (by checking U^T @ H @ V = Sigma)
                        // This ensures consistency with Python's np.linalg.svd
                        for (let i = 0; i < 3; i++) {
                            if (sigma[i] > 1e-10) {
                                // Check sign: U[:, i]^T @ H @ V[:, i] should be positive
                                const Ut_row = [U[0][i], U[1][i], U[2][i]];
                                const HV_col = [0, 0, 0];
                                for (let k = 0; k < 3; k++) {
                                    HV_col[k] = H[k][0] * V[0][i] + H[k][1] * V[1][i] + H[k][2] * V[2][i];
                                }
                                const dot = Ut_row[0] * HV_col[0] + Ut_row[1] * HV_col[1] + Ut_row[2] * HV_col[2];
                                if (dot < 0) {
                                    // Flip U column to ensure correct sign
                                    U[0][i] *= -1;
                                    U[1][i] *= -1;
                                    U[2][i] *= -1;
                                }
                            }
                        }
                        
                        // Return format: {u: U, v: V, q: sigma}
                        // U and V are column-major (eigenvectors as columns)
                        // This matches what kabschAlgorithm expects
                        return { u: U, v: V, q: sigma };
                    } catch (e) {
                        console.error('Built-in SVD failed:', e);
                        return null;
                    }
                },
                transpose3(M) {
                    return [[M[0][0], M[1][0], M[2][0]],
                            [M[0][1], M[1][1], M[2][1]],
                            [M[0][2], M[1][2], M[2][2]]];
                },
                jacobi3x3(A) {
                    // Jacobi method for 3x3 symmetric matrix eigenvalue decomposition
                    try {
                        let V = [[1,0,0],[0,1,0],[0,0,1]];
                        let B = [[A[0][0],A[0][1],A[0][2]],
                                [A[1][0],A[1][1],A[1][2]],
                                [A[2][0],A[2][1],A[2][2]]];
                        
                        // Iterate until convergence
                        for (let iter = 0; iter < 10; iter++) {
                            // Find largest off-diagonal element
                            let maxVal = 0;
                            let p = 0, q = 1;
                            for (let i = 0; i < 3; i++) {
                                for (let j = i+1; j < 3; j++) {
                                    const absVal = Math.abs(B[i][j]);
                                    if (absVal > maxVal) {
                                        maxVal = absVal;
                                        p = i;
                                        q = j;
                                    }
                                }
                            }
                            
                            if (maxVal < 1e-10) break;
                            
                            // Compute rotation angle
                            const theta = 0.5 * Math.atan2(2 * B[p][q], B[q][q] - B[p][p]);
                            const c = Math.cos(theta);
                            const s = Math.sin(theta);
                            
                            // Apply rotation to B
                            const Bpp = B[p][p] * c * c + B[q][q] * s * s + 2 * B[p][q] * c * s;
                            const Bqq = B[p][p] * s * s + B[q][q] * c * c - 2 * B[p][q] * c * s;
                            const Bpq = (B[q][q] - B[p][p]) * c * s + B[p][q] * (c * c - s * s);
                            
                            for (let k = 0; k < 3; k++) {
                                if (k !== p && k !== q) {
                                    const Bpk = B[p][k] * c + B[q][k] * s;
                                    const Bqk = -B[p][k] * s + B[q][k] * c;
                                    B[p][k] = Bpk;
                                    B[k][p] = Bpk;
                                    B[q][k] = Bqk;
                                    B[k][q] = Bqk;
                                }
                            }
                            
                            B[p][p] = Bpp;
                            B[q][q] = Bqq;
                            B[p][q] = Bpq;
                            B[q][p] = Bpq;
                            
                            // Update V
                            for (let k = 0; k < 3; k++) {
                                const Vkp = V[k][p] * c + V[k][q] * s;
                                const Vkq = -V[k][p] * s + V[k][q] * c;
                                V[k][p] = Vkp;
                                V[k][q] = Vkq;
                            }
                        }
                        
                        const values = [B[0][0], B[1][1], B[2][2]];
                        // V is stored with eigenvectors as columns: V[j][i] = j-th component of i-th eigenvector
                        // Return as rows for easier access: vectors[i][j] = j-th component of i-th eigenvector
                        const vectors = [[V[0][0],V[1][0],V[2][0]],
                                        [V[0][1],V[1][1],V[2][1]],
                                        [V[0][2],V[1][2],V[2][2]]];
                        
                        return { values, vectors };
                    } catch (e) {
                        console.error('Jacobi method failed:', e);
                        return null;
                    }
                },
                // Calculate RMSD using Kabsch algorithm (standard method)
                calculateRMSDKabsch(refAtoms, predAtoms, minLen) {
                    const refSubset = refAtoms.slice(0, minLen);
                    const predSubset = predAtoms.slice(0, minLen);
                    
                    const alignment = this.kabschAlign(refSubset, predSubset);
                    if (!alignment) {
                        // Check if SVD library is available
                        const svdAvailable = typeof SVDJS !== 'undefined' || 
                                            (typeof window !== 'undefined' && window.SVDJS) ||
                                            (typeof window !== 'undefined' && window.SVD) ||
                                            typeof SVD !== 'undefined';
                        
                        if (!svdAvailable) {
                            this.rmsdError = 'Structure alignment failed: SVD library not loaded. Please refresh the page and try again.';
                        } else {
                            this.rmsdError = 'Structure alignment failed. Please check if structures are valid. The SVD calculation may have failed. Check browser console for details.';
                        }
                        return null;
                    }
                    
                    const { refCoords, alignedCoords } = alignment;
                    let sumSqDiff = 0;
                    for (let i = 0; i < minLen; i++) {
                        const [rx, ry, rz] = refCoords[i];
                        const [px, py, pz] = alignedCoords[i];
                        const dx = rx - px;
                        const dy = ry - py;
                        const dz = rz - pz;
                        sumSqDiff += dx * dx + dy * dy + dz * dz;
                    }
                    
                    const rmsd = Math.sqrt(sumSqDiff / minLen);
                    
                    return {
                        rmsd: rmsd,
                        alignedAtoms: minLen,
                        totalAtoms: minLen
                    };
                },
                // Calculate TM-align score (simplified implementation based on Kabsch alignment)
                calculateTMalign(refAtoms, predAtoms, minLen) {
                    // First perform Kabsch alignment to get optimal superposition
                    const alignment = this.kabschAlign(refAtoms.slice(0, minLen), predAtoms.slice(0, minLen));
                    if (!alignment) {
                        this.rmsdError = 'TM-align failed: Kabsch alignment error';
                        return null;
                    }
                    
                    const { refCoords, alignedCoords } = alignment;
                    
                    // Calculate distances for all aligned atoms
                    const distances = [];
                    for (let i = 0; i < minLen; i++) {
                        const [rx, ry, rz] = refCoords[i];
                        const [px, py, pz] = alignedCoords[i];
                        const dx = rx - px;
                        const dy = ry - py;
                        const dz = rz - pz;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        distances.push(dist);
                    }
                    
                    // Calculate RMSD
                    const sumSqDiff = distances.reduce((sum, d) => sum + d * d, 0);
                    const rmsd = Math.sqrt(sumSqDiff / minLen);
                    
                    // Calculate TM-score
                    // TM-score = (1/L) * Σ[1/(1 + (d_i/d0)^2)]
                    // where d0 = 1.24 * (L - 15)^(1/3) for L > 15, or 0.5 for L <= 15
                    // L is the length of the longer sequence
                    const L = Math.max(refAtoms.length, predAtoms.length);
                    const d0 = L > 15 ? 1.24 * Math.pow(L - 15, 1/3) : 0.5;
                    
                    let tmScoreSum = 0;
                    for (const d of distances) {
                        tmScoreSum += 1 / (1 + Math.pow(d / d0, 2));
                    }
                    const tmScore = tmScoreSum / L;
                    
                    // Calculate number of aligned residues (within reasonable distance)
                    // Typically, residues with distance < d0 are considered aligned
                    const alignedResidues = distances.filter(d => d < d0).length;
                    
                    return {
                        rmsd: rmsd,
                        tmScore: tmScore,
                        alignedAtoms: alignedResidues,
                        totalAtoms: minLen
                    };
                },
                // Calculate RMSD using iterative prune alignment (similar to PyMOL)
                // Strategy: 1) Initial Kabsch alignment on all atoms, 2) Calculate deviations, 3) Remove outliers, 4) Re-align on inliers, 5) Repeat
                // Only continue if RMSD improves or inliers increase
                calculateRMSDIterative(refAtoms, predAtoms, minLen) {
                    const cutoff = this.rmsdCutoff || 2.0;
                    const maxCycles = this.rmsdMaxCycles || 5;
                    
                    // Use subset - keep original coordinates (not centered)
                    // Initial alignment: all atoms correspond to each other (Cα to Cα)
                    const refAll = refAtoms.slice(0, minLen);
                    const predAll = predAtoms.slice(0, minLen);
                    
                    // Initialize mask (all atoms included for initial alignment)
                    let mask = new Array(minLen).fill(true);
                    let distances = null;
                    let prevDistances = null; // Store distances from previous cycle
                    let prevMask = null; // Store mask from previous cycle
                    let bestRmsd = null; // Track best RMSD so far
                    let bestMask = null; // Track best mask so far
                    let bestDistances = null; // Track best distances so far
                    let usedCycles = 0;
                    
                    // Iterative alignment loop (PyMOL style)
                    for (let cycle = 0; cycle < maxCycles; cycle++) {
                        usedCycles = cycle + 1;
                        
                        // Filter coordinates by current mask (inliers only)
                        const refInliers = refAll.filter((_, i) => mask[i]);
                        const predInliers = predAll.filter((_, i) => mask[i]);
                        
                        if (refInliers.length < 3 || predInliers.length < 3) {
                            console.log(`Iterative alignment: cycle ${cycle + 1}, not enough inliers (${refInliers.length})`);
                            break;
                        }
                        
                        // If too few inliers, warn but continue (minimum 3 for SVD)
                        // However, very few inliers may lead to poor alignment
                        if (refInliers.length < minLen * 0.1) {
                            console.warn(`Iterative alignment: cycle ${cycle + 1}, very few inliers (${refInliers.length}/${minLen}, ${(refInliers.length/minLen*100).toFixed(1)}%). Alignment may be unstable.`);
                        }
                        
                        console.log(`Iterative alignment: cycle ${cycle + 1}, inliers: ${refInliers.length}/${minLen}`);
                        
                        // Step 1: Calculate R and t using Kabsch algorithm on inliers (matching Python)
                        // Python: sup.set_atoms(ref_inliers, mob_inliers); R, t = sup.rotran
                        // We use kabschAlgorithm directly to get R and t (same as Python's Superimposer)
                        // NOTE: For cycle 0, we use all atoms (same as standard Kabsch), so results should match
                        const rtResult = this.kabschAlgorithm(refInliers, predInliers);
                        if (!rtResult || !rtResult.R || !rtResult.t) {
                            this.rmsdError = 'Iterative alignment failed: Kabsch algorithm error in cycle ' + (cycle + 1);
                            return null;
                        }
                        
                        const R = rtResult.R;
                        const t = rtResult.t;
                        
                        // Debug: In cycle 0, the result should match standard Kabsch
                        if (cycle === 0) {
                            // Verify: cycle 0 should use all atoms, same as Kabsch
                            if (refInliers.length !== minLen || predInliers.length !== minLen) {
                                console.warn(`Iterative alignment: cycle 0 should use all atoms, but got ${refInliers.length}/${minLen} inliers`);
                            }
                        }
                        
                        // Verify R is valid rotation matrix (det(R) ≈ 1.0)
                        const detR = this.det3(R);
                        if (cycle === 0) {
                            console.log(`Iterative alignment: R determinant: ${detR.toFixed(6)} (should be ~1.0)`);
                            if (Math.abs(detR - 1.0) > 0.1) {
                                console.warn(`Iterative alignment: R determinant deviates from 1.0 by ${Math.abs(detR - 1.0).toFixed(6)}`);
                            }
                        }
                        
                        // Step 2: Transform ALL predicted coordinates using R and t (matching Python)
                        // Python: mob_aligned = (R @ mob_coords_all.T).T + t
                        // Apply transformation to all atoms, not just inliers
                        const predAligned = predAll.map(([x,y,z]) => {
                            const v = this.mul3vec(R, [x,y,z]);
                            return [v[0]+t[0], v[1]+t[1], v[2]+t[2]];
                        });
                        
                        // Calculate distances for all atoms: ||ref_all - pred_aligned||
                        distances = refAll.map(([rx,ry,rz], i) => {
                            const [px,py,pz] = predAligned[i];
                            const dx = rx - px;
                            const dy = ry - py;
                            const dz = rz - pz;
                            return Math.sqrt(dx*dx + dy*dy + dz*dz);
                        });
                        
                        // Safety check: if distances increased significantly, this may indicate instability
                        // This can happen when too few inliers are used for alignment
                        if (cycle > 0 && distances.length > 0) {
                            // Store max distance from previous cycle for comparison
                            if (typeof this._prevMaxDist === 'undefined') {
                                this._prevMaxDist = Math.max(...distances); // First time, store current
                            } else {
                                const prevMaxDist = this._prevMaxDist;
                                const currentMaxDist = Math.max(...distances);
                                if (currentMaxDist > prevMaxDist * 1.5) {
                                    console.warn(`Iterative alignment: cycle ${cycle + 1}, distances increased significantly (${prevMaxDist.toFixed(2)} → ${currentMaxDist.toFixed(2)} Å).`);
                                    console.warn(`  This suggests alignment instability. Current inliers (${refInliers.length}/${minLen}, ${(refInliers.length/minLen*100).toFixed(1)}%) may be insufficient or poorly distributed.`);
                                    console.warn(`  Consider using a larger cutoff. Iterative alignment may not improve RMSD in this case.`);
                                    console.warn(`  Recommendation: Use standard Kabsch method if distances continue to increase.`);
                                }
                                this._prevMaxDist = currentMaxDist;
                            }
                        } else if (cycle === 0) {
                            // Initialize for cycle 0
                            this._prevMaxDist = Math.max(...distances);
                        }
                        
                        // Debug: check alignment quality
                        if (cycle === 0) {
                            // Check a few sample points before and after alignment
                            const sampleIdx = Math.min(3, refAll.length - 1);
                            const refSample = refAll[sampleIdx];
                            const predSampleBefore = predAll[sampleIdx];
                            const predSampleAfter = predAligned[sampleIdx];
                            console.log(`Iterative alignment: cycle ${cycle + 1}, sample atom ${sampleIdx}:`);
                            console.log(`  ref: [${refSample.map(v => v.toFixed(2)).join(', ')}]`);
                            console.log(`  pred before: [${predSampleBefore.map(v => v.toFixed(2)).join(', ')}]`);
                            console.log(`  pred after: [${predSampleAfter.map(v => v.toFixed(2)).join(', ')}]`);
                            console.log(`  distance: ${distances[sampleIdx].toFixed(3)} Å`);
                            console.log(`  R determinant: ${this.det3(R).toFixed(6)} (should be ~1.0)`);
                            console.log(`  translation: [${t.map(v => v.toFixed(2)).join(', ')}]`);
                            
                            // Check if alignment actually improved
                            const distBefore = Math.sqrt(
                                Math.pow(refSample[0] - predSampleBefore[0], 2) +
                                Math.pow(refSample[1] - predSampleBefore[1], 2) +
                                Math.pow(refSample[2] - predSampleBefore[2], 2)
                            );
                            console.log(`  distance before alignment: ${distBefore.toFixed(3)} Å`);
                        }
                        
                        // Calculate current RMSD from inliers (before updating mask)
                        // This helps track if alignment is improving
                        const currentInlierDistances = distances.filter((_, i) => mask[i]);
                        const currentInlierRmsd = currentInlierDistances.length > 0 
                            ? Math.sqrt(currentInlierDistances.reduce((sum, d) => sum + d * d, 0) / currentInlierDistances.length)
                            : Infinity;
                        
                        // Track best result so far
                        if (bestRmsd === null || currentInlierRmsd < bestRmsd) {
                            bestRmsd = currentInlierRmsd;
                            bestMask = [...mask];
                            bestDistances = [...distances];
                            console.log(`Iterative alignment: cycle ${cycle + 1}, improved RMSD to ${bestRmsd.toFixed(4)} Å (inliers: ${currentInlierDistances.length}/${minLen})`);
                        } else if (cycle > 0 && currentInlierRmsd > bestRmsd * 1.05) {
                            // If RMSD worsened by more than 5%, warn but continue
                            console.warn(`Iterative alignment: cycle ${cycle + 1}, RMSD worsened (${currentInlierRmsd.toFixed(4)} vs best ${bestRmsd.toFixed(4)} Å). Continuing but may revert to best result.`);
                        }
                        
                        // Update mask: keep atoms with distance < cutoff
                        const newMask = distances.map(d => d < cutoff);
                        const inlierCount = newMask.filter(m => m).length;
                        const maxDist = Math.max(...distances);
                        const minDist = Math.min(...distances);
                        const avgDist = distances.reduce((a, b) => a + b, 0) / distances.length;
                        const medianDist = distances.slice().sort((a, b) => a - b)[Math.floor(distances.length / 2)];
                        console.log(`Iterative alignment: cycle ${cycle + 1}, inliers: ${inlierCount}/${minLen}, max dist: ${maxDist.toFixed(3)}, avg dist: ${avgDist.toFixed(3)}, median dist: ${medianDist.toFixed(3)}, min dist: ${minDist.toFixed(3)}, RMSD: ${currentInlierRmsd.toFixed(4)} Å`);
                        
                        // If distances increased significantly, this may indicate alignment instability
                        if (cycle > 0 && maxDist > this._prevMaxDist * 1.5) {
                            console.warn(`Iterative alignment: cycle ${cycle + 1}, distances increased significantly. This may indicate alignment instability with current inliers.`);
                        }
                        
                        // If all atoms are inliers (cutoff too large), suggest a more appropriate cutoff
                        if (inlierCount === minLen && cycle === 0) {
                            // Suggest cutoff based on percentile or a fraction of max distance
                            // Use 75th percentile or 0.8 * max distance, whichever is smaller
                            const sortedDistances = distances.slice().sort((a, b) => a - b);
                            const p75Dist = sortedDistances[Math.floor(sortedDistances.length * 0.75)];
                            const suggestedCutoff1 = Math.ceil(p75Dist * 1.1); // 75th percentile * 1.1
                            const suggestedCutoff2 = Math.ceil(maxDist * 0.8); // 80% of max distance
                            const suggestedCutoff = Math.min(suggestedCutoff1, suggestedCutoff2);
                            
                            console.log(`  Note: All atoms are inliers. Current cutoff ${cutoff} Å is larger than max distance ${maxDist.toFixed(2)} Å.`);
                            console.log(`  Suggested cutoff for pruning outliers: ${suggestedCutoff} Å (75th percentile: ${p75Dist.toFixed(2)} Å, max: ${maxDist.toFixed(2)} Å)`);
                            console.log(`  This will retain approximately ${distances.filter(d => d < suggestedCutoff).length}/${minLen} atoms as inliers.`);
                            console.log(`  Recommendation: Increase cutoff to ${suggestedCutoff} Å or higher to enable iterative pruning.`);
                        }
                        
                        // If no atoms are inliers (cutoff too small), this is a critical issue
                        if (inlierCount === 0 && cycle === 0) {
                            console.error(`  CRITICAL: All atoms pruned at cycle 1. Cutoff ${cutoff} Å is too small (min distance: ${minDist.toFixed(2)} Å, max: ${maxDist.toFixed(2)} Å).`);
                            console.error(`  Cannot perform iterative pruning. Using all atoms (cycle 0 Kabsch result) for RMSD.`);
                            console.error(`  Recommendation: Increase cutoff to at least ${Math.ceil(minDist * 1.1)} Å to retain some atoms for iterative pruning.`);
                        }
                        
                        // Check for convergence (matching Python: np.array_equal(new_mask, mask))
                        let maskEqual = true;
                        for (let i = 0; i < minLen; i++) {
                            if (newMask[i] !== mask[i]) {
                                maskEqual = false;
                                break;
                            }
                        }
                        
                        if (maskEqual && cycle > 0) {
                            // Only break if mask unchanged AND we've done at least one iteration
                            // This ensures we do at least one full alignment cycle
                            console.log(`Iterative alignment: converged at cycle ${cycle + 1} (mask unchanged)`);
                            break; // Converged
                        }
                        
                        // If first iteration and mask unchanged, continue to second iteration to refine alignment
                        if (maskEqual && cycle === 0) {
                            console.log(`Iterative alignment: cycle 1 mask unchanged, continuing to refine alignment`);
                        }
                        
                        // Check if any atoms remain (matching Python: if not np.any(new_mask): break)
                        if (!newMask.some(m => m)) {
                            console.log(`Iterative alignment: all atoms pruned at cycle ${cycle + 1}`);
                            // If all atoms pruned in cycle 0, this means cutoff is too small
                            // Use all atoms (original alignment result) for final RMSD
                            if (cycle === 0) {
                                console.warn(`  All atoms pruned at cycle 1. Cutoff ${cutoff} Å is too small (min distance: ${minDist.toFixed(2)} Å).`);
                                console.warn(`  Using all atoms (cycle 0 Kabsch result) for final RMSD calculation.`);
                                // Keep mask as all true (all atoms) and use current distances
                                mask = new Array(minLen).fill(true);
                                // Don't break - continue to use this result
                                break; // Stop iteration, but use all atoms result
                            }
                            // If all atoms pruned in cycle > 0, use previous cycle result
                            if (cycle > 0 && prevMask && prevDistances) {
                                console.warn(`  All atoms pruned after cycle ${cycle + 1}. This indicates alignment instability.`);
                                console.warn(`  Using mask and distances from previous cycle (cycle ${cycle}) for final RMSD calculation.`);
                                // Restore previous mask and distances
                                mask = prevMask;
                                distances = prevDistances;
                                break;
                            }
                            // Fallback: if no previous result, use all atoms
                            console.warn(`  No previous result available. Using all atoms for final RMSD.`);
                            mask = new Array(minLen).fill(true);
                            break; // All atoms pruned
                        }
                        
                        // Store current mask and distances before updating (for fallback if next cycle fails)
                        prevMask = [...mask];
                        prevDistances = distances ? [...distances] : null;
                        
                        // Update mask for next iteration
                        mask = newMask;
                    }
                    
                    if (!distances) {
                        this.rmsdError = 'Iterative alignment failed: Could not compute distances';
                        return null;
                    }
                    
                    // Use best result if available (better than final result)
                    // This ensures we always return the best RMSD achieved during iteration
                    let finalMask = mask;
                    let finalDistances = distances;
                    if (bestMask && bestDistances && bestRmsd !== null) {
                        const finalInlierDistances = distances.filter((_, i) => mask[i]);
                        const finalInlierRmsd = finalInlierDistances.length > 0 
                            ? Math.sqrt(finalInlierDistances.reduce((sum, d) => sum + d * d, 0) / finalInlierDistances.length)
                            : Infinity;
                        
                        if (bestRmsd < finalInlierRmsd) {
                            console.log(`Iterative alignment: using best result (RMSD: ${bestRmsd.toFixed(4)} Å vs current ${finalInlierRmsd.toFixed(4)} Å)`);
                            finalMask = bestMask;
                            finalDistances = bestDistances;
                        }
                    }
                    
                    // If final mask has no inliers but we have distances, use all atoms (fallback to cycle 0 result)
                    if (!finalMask.some(m => m) && finalDistances && finalDistances.length === minLen) {
                        console.warn(`Iterative alignment: final mask has no inliers. Using all atoms (cycle 0 Kabsch result) for RMSD calculation.`);
                        finalMask = new Array(minLen).fill(true);
                    }
                    
                    // Calculate final RMSD from inlier atoms only
                    // final_rmsd = sqrt(mean(distances[mask]^2)) (matching Python)
                    // Python: if not np.any(mask): raise ValueError("All atoms pruned; try increasing cutoff or cycles")
                    const inlierDistances = finalDistances.filter((_, i) => finalMask[i]);
                    if (inlierDistances.length === 0) {
                        const suggestedCutoff = finalDistances ? Math.ceil(Math.max(...finalDistances) * 1.2) : cutoff * 10;
                        this.rmsdError = `All atoms pruned during iterative alignment. Cutoff ${cutoff} Å is too small. Suggested cutoff: ${suggestedCutoff} Å. Please increase cutoff and try again.`;
                        console.error(this.rmsdError);
                        return null;
                    }
                    
                    const sumSqDiff = inlierDistances.reduce((sum, d) => sum + d * d, 0);
                    const finalRmsd = Math.sqrt(sumSqDiff / inlierDistances.length);
                    const alignedAtoms = inlierDistances.length;
                    
                    // Also calculate RMSD for all atoms for comparison
                    const allRmsd = Math.sqrt(distances.reduce((sum, d) => sum + d * d, 0) / distances.length);
                    console.log(`Iterative alignment: final RMSD (inliers only): ${finalRmsd.toFixed(4)}, all atoms: ${allRmsd.toFixed(4)}, inliers: ${alignedAtoms}/${minLen}`);
                    
                    // Compare with standard Kabsch: if only one cycle and all atoms are inliers, should match
                    if (usedCycles === 1 && alignedAtoms === minLen) {
                        console.log(`  Note: Single cycle with all atoms as inliers. This should match standard Kabsch result (${allRmsd.toFixed(4)} Å).`);
                    } else if (finalRmsd > allRmsd) {
                        console.warn(`  Warning: Iterative alignment RMSD (${finalRmsd.toFixed(4)} Å) is LARGER than all-atoms RMSD (${allRmsd.toFixed(4)} Å).`);
                        console.warn(`  This suggests iterative pruning did not improve alignment. Consider using standard Kabsch method instead.`);
                    }
                    
                    // If all atoms are inliers, this means cutoff was too large
                    if (alignedAtoms === minLen) {
                        const maxDist = Math.max(...distances);
                        const sortedDistances = distances.slice().sort((a, b) => a - b);
                        const p75Dist = sortedDistances[Math.floor(sortedDistances.length * 0.75)];
                        const suggestedCutoff1 = Math.ceil(p75Dist * 1.1);
                        const suggestedCutoff2 = Math.ceil(maxDist * 0.8);
                        const suggestedCutoff = Math.min(suggestedCutoff1, suggestedCutoff2);
                        const expectedInliers = distances.filter(d => d < suggestedCutoff).length;
                        
                        console.log(`  Note: All atoms retained as inliers. Cutoff ${cutoff} Å is larger than max distance ${maxDist.toFixed(2)} Å.`);
                        console.log(`  For better pruning, try cutoff: ${suggestedCutoff} Å`);
                        console.log(`  This would retain approximately ${expectedInliers}/${minLen} atoms (${(expectedInliers/minLen*100).toFixed(1)}%) as inliers.`);
                    }
                    
                    return {
                        rmsd: finalRmsd,
                        alignedAtoms: alignedAtoms,
                        totalAtoms: minLen,
                        cyclesUsed: usedCycles
                    };
                },
                calculateRMSD() {
                    this.rmsdError = '';
                    this.rmsdResult = null;
                    this.showRmsdResult = false;
                    // start progress
                    this.rmsdProcessing.active = true;
                    this.rmsdProcessing.value = 10;
                    if (this._rmsdTimer) { clearInterval(this._rmsdTimer); this._rmsdTimer=null; }
                    this._rmsdTimer = setInterval(()=>{ if (this.rmsdProcessing.value < 90) this.rmsdProcessing.value += 5; }, 150);
                    
                    // If using embedded placeholders, hydrate contents/files now
                    try {
                        if (this.useEmbeddedRef && (!this.referencePdbContent || !this.referenceFileObj)) {
                            const text = this.getEmbeddedText(this.embeddedRefId);
                            if (!text) throw new Error('Embedded reference not found');
                            this.referencePdbContent = text;
                            const blob = new Blob([text], { type: 'chemical/x-pdb' });
                            this.referenceFileObj = new File([blob], this.referenceFileName || 'reference.pdb', { type: 'chemical/x-pdb' });
                        }
                        if (this.useEmbeddedPred && (!this.predictedPdbContent || !this.predictedFileObj)) {
                            const text = this.getEmbeddedText(this.embeddedPredId);
                            if (!text) throw new Error('Embedded predicted not found');
                            this.predictedPdbContent = text;
                            const mime = (this.predictedFileName || '').toLowerCase().endsWith('.cif') ? 'chemical/x-cif' : 'chemical/x-pdb';
                            const blob = new Blob([text], { type: mime });
                            this.predictedFileObj = new File([blob], this.predictedFileName || 'predicted.pdb', { type: mime });
                        }
                    } catch (e) {
                        this.rmsdError = e.message || 'Failed to prepare embedded examples';
                        // Clean up progress
                        if(this._rmsdTimer){ clearInterval(this._rmsdTimer); this._rmsdTimer=null; }
                        this.rmsdProcessing.value=100;
                        setTimeout(()=>{ this.rmsdProcessing.active=false; this.rmsdProcessing.value=0; }, 300);
                        return;
                    }

                    if (!this.referencePdbContent || !this.predictedPdbContent) {
                        this.rmsdError = 'Please upload both reference and predicted PDB files.';
                        // Clean up progress
                        if(this._rmsdTimer){ clearInterval(this._rmsdTimer); this._rmsdTimer=null; }
                        this.rmsdProcessing.value=100;
                        setTimeout(()=>{ this.rmsdProcessing.active=false; this.rmsdProcessing.value=0; }, 300);
                        return;
                    }
                    
                    try {
                        
                        const refAtoms = this.parseStructureText(this.referencePdbContent, this.referenceFileName);
                        const predAtoms = this.parseStructureText(this.predictedPdbContent, this.predictedFileName);
                        
                        if (refAtoms.length === 0) {
                            this.rmsdError = 'No CA atoms found in reference structure.';
                            // Clean up progress
                            if(this._rmsdTimer){ clearInterval(this._rmsdTimer); this._rmsdTimer=null; }
                            this.rmsdProcessing.value=100;
                            setTimeout(()=>{ this.rmsdProcessing.active=false; this.rmsdProcessing.value=0; }, 300);
                            return;
                        }
                        if (predAtoms.length === 0) {
                            this.rmsdError = 'No CA atoms found in predicted structure.';
                            // Clean up progress
                            if(this._rmsdTimer){ clearInterval(this._rmsdTimer); this._rmsdTimer=null; }
                            this.rmsdProcessing.value=100;
                            setTimeout(()=>{ this.rmsdProcessing.active=false; this.rmsdProcessing.value=0; }, 300);
                            return;
                        }
                        
                        const minLen = Math.min(refAtoms.length, predAtoms.length);
                        if (minLen < 3) {
                            this.rmsdError = 'Not enough atoms for RMSD calculation (minimum 3 CA atoms required).';
                            // Clean up progress
                            if(this._rmsdTimer){ clearInterval(this._rmsdTimer); this._rmsdTimer=null; }
                            this.rmsdProcessing.value=100;
                            setTimeout(()=>{ this.rmsdProcessing.active=false; this.rmsdProcessing.value=0; }, 300);
                            return;
                        }
                        
                        // Choose alignment method
                        let rmsdResult;
                        if (this.rmsdMethod === 'iterative') {
                            rmsdResult = this.calculateRMSDIterative(refAtoms, predAtoms, minLen);
                        } else if (this.rmsdMethod === 'tmalign') {
                            rmsdResult = this.calculateTMalign(refAtoms, predAtoms, minLen);
                        } else {
                            rmsdResult = this.calculateRMSDKabsch(refAtoms, predAtoms, minLen);
                        }
                        
                        if (!rmsdResult) {
                            // Clean up progress
                            if(this._rmsdTimer){ clearInterval(this._rmsdTimer); this._rmsdTimer=null; }
                            this.rmsdProcessing.value=100;
                            setTimeout(()=>{ this.rmsdProcessing.active=false; this.rmsdProcessing.value=0; }, 300);
                            return;
                        }
                        
                        this.rmsdResult = rmsdResult;
                        this.rmsdError = '';
                        this.showRmsdResult = true;
                        this.scrollTo('structure');
                    } catch (e) {
                        this.rmsdError = 'RMSD calculation failed: ' + (e.message || 'Unknown error');
                        this.rmsdResult = null;
                    } finally {
                        try {
                            if(this._rmsdTimer){ 
                                clearInterval(this._rmsdTimer); 
                                this._rmsdTimer=null; 
                            }
                            this.rmsdProcessing.value=100;
                            setTimeout(()=>{ 
                                this.rmsdProcessing.active=false; 
                                this.rmsdProcessing.value=0; 
                            }, 300);
                        } catch(_) {}
                    }
                }
                ,
                parseStructureText(text, filename) {
                    const isCif = (filename || '').toLowerCase().endsWith('.cif') || /_atom_site\./.test(text);
                    return isCif ? this.parseCIF(text) : this.parsePDB(text);
                },
                parseCIF(cifText) {
                    const lines = cifText.split('\n');
                    let inLoop = false; const headerCols = {}; const ca = [];
                    for (let raw of lines) {
                        const line = raw.trim(); if (!line) continue;
                        if (line.startsWith('loop_')) { inLoop = false; for (const k in headerCols) delete headerCols[k]; continue; }
                        if (line.startsWith('_atom_site.')) { inLoop = true; const name = line.replace('_atom_site.', '').trim(); headerCols[name] = Object.keys(headerCols).length; continue; }
                        if (inLoop && !line.startsWith('#')) {
                            const parts = line.split(/\s+/);
                            const li = headerCols['label_atom_id'], xi = headerCols['Cartn_x'], yi = headerCols['Cartn_y'], zi = headerCols['Cartn_z'];
                            if (li==null||xi==null||yi==null||zi==null) continue;
                            if (parts.length <= Math.max(li,xi,yi,zi)) continue;
                            if (parts[li] === 'CA') {
                                const x = parseFloat(parts[xi]); const y = parseFloat(parts[yi]); const z = parseFloat(parts[zi]);
                                if (!Number.isNaN(x) && !Number.isNaN(y) && !Number.isNaN(z)) ca.push([x,y,z]);
                            }
                        }
                    }
                    return ca;
                },
                // Load example data
                loadEpitopeExample(){
                    try {
                        this.isNetmhciiLoading = true;
                        this.errorMessage = '';
                        
                        // Load example data from embedded script tag
                        const exampleDataEl = document.getElementById('example_netmhcii_data');
                        if (!exampleDataEl) {
                            throw new Error('Example data not found in HTML');
                        }
                        
                        // Get the text content (already in tab-separated format)
                        const textContent = exampleDataEl.textContent || exampleDataEl.innerText || '';
                        if (!textContent || textContent.trim().length === 0) {
                            throw new Error('Example data is empty');
                        }
                        
                        // Use the text content directly (it's already in the correct format)
                        this.netmhciiFileContent = textContent.trim();
                        this.netmhciiFileName = 'DP_P03146_NetMHCIIpan.xls (example)';
                        this.epitopeRows = [];
                        
                        // Set example VLP sequence
                        const exampleSequence = 'MDIDPYKEFGATVELLSFLPSDFFPSVRDLLDTASALYREALESPEHCSPHHTALRQAILCWGELMTLATWVGVNLEDPASRDLVVSYVNTNMGLKFRQLLWFHISCLTFGRETVIEYLVSFGVWIRTPPAYRPPNAPILSTLPETTVV';
                        this.vlpSequenceText = exampleSequence;
                        this.validateVlpSequence();
                        
                        this.scrollTo('epitope');
                    } catch (e) {
                        console.error('Error loading example:', e);
                        this.errorMessage = 'Failed to load example: ' + (e.message || 'Unknown error');
                    } finally {
                        this.isNetmhciiLoading = false;
                    }
                },
                // FASTA upload (kept for backward compatibility)
                handleFastaUpload(evt){ const file = evt.target.files && evt.target.files[0]; if(!file) return; this.fastaFileName=file.name; const reader=new FileReader(); reader.onload=(e)=>{ this.fastaText=(e.target.result||'').toString(); }; reader.readAsText(file,'utf-8'); },
                // Validate VLP sequence
                validateVlpSequence(){
                    const text = this.vlpSequenceText.trim();
                    this.vlpSequenceLength = 0;
                    this.vlpSequenceError = '';
                    
                    if(!text){
                        this.vlpSequenceLength = 0;
                        return;
                    }
                    
                    // Remove whitespace and newlines, convert to uppercase
                    const cleanSeq = text.replace(/\s+/g, '').toUpperCase();
                    
                    // Valid amino acid letters: ACDEFGHIKLMNPQRSTVWY (standard 20)
                    // Check for invalid characters (anything that's not a valid amino acid letter)
                    const validAminoAcids = /^[ACDEFGHIKLMNPQRSTVWY]*$/;
                    const hasInvalidChars = !/^[ACDEFGHIKLMNPQRSTVWY]*$/.test(cleanSeq);
                    
                    if(hasInvalidChars){
                        // Find invalid characters
                        const invalidChars = cleanSeq.match(/[^ACDEFGHIKLMNPQRSTVWY]/g);
                        if(invalidChars){
                            const uniqueInvalid = [...new Set(invalidChars)];
                            this.vlpSequenceError = `Invalid characters found: ${uniqueInvalid.join(', ')}. Only standard amino acids (ACDEFGHIKLMNPQRSTVWY) are allowed.`;
                        }
                        this.vlpSequenceLength = 0;
                        return;
                    }
                    
                    // Calculate sequence length (only standard amino acids)
                    this.vlpSequenceLength = cleanSeq.length;
                    
                    if(this.vlpSequenceLength === 0){
                        this.vlpSequenceError = 'Sequence is empty.';
                        return;
                    }
                    
                    if(this.vlpSequenceLength < 10){
                        this.vlpSequenceError = 'Sequence is too short (minimum 10 amino acids required).';
                        return;
                    }
                    
                    // Sequence is valid
                    this.vlpSequenceError = '';
                },
                // epitopes identification
                runAdvancedEpitopeAnalysis(){
                    console.log('runAdvancedEpitopeAnalysis called');
                    console.log('netmhciiFileContent:', this.netmhciiFileContent ? 'exists' : 'missing');
                    console.log('vlpSequenceText:', this.vlpSequenceText ? 'exists (' + this.vlpSequenceText.length + ' chars)' : 'missing');
                    console.log('vlpSequenceError:', this.vlpSequenceError);
                    console.log('vlpSequenceLength:', this.vlpSequenceLength);
                    
                    try{
                        // Clear previous results and errors
                        this.advancedEpitopes = [];
                        this.errorMessage = '';
                        
                        // Validate inputs
                        if(!this.netmhciiFileContent){ 
                            this.errorMessage='Please upload NetMHCIIpan output file.'; 
                            return; 
                        }
                        if(!this.vlpSequenceText || this.vlpSequenceText.trim() === ''){ 
                            this.errorMessage='Please enter a VLP sequence.'; 
                            return; 
                        }
                        if(this.vlpSequenceError){ 
                            this.errorMessage='VLP sequence has errors: ' + this.vlpSequenceError; 
                            return; 
                        }
                        if(this.vlpSequenceLength === 0){ 
                            this.errorMessage='VLP sequence is empty or invalid.'; 
                            return; 
                        }
                        
                        // start progress
                        this.epitopeProcessing.active = true;
                        this.epitopeProcessing.value = 10;
                        if (this._epiTimer) { clearInterval(this._epiTimer); this._epiTimer=null; }
                        this._epiTimer = setInterval(()=>{
                            if (this.epitopeProcessing.value < 90) this.epitopeProcessing.value += 5;
                        }, 200);
                        
                        // Get full sequence from text input (already validated, just clean whitespace and uppercase)
                        const fullSequence = this.vlpSequenceText.replace(/\s+/g, '').toUpperCase();
                        if(!fullSequence || fullSequence.length === 0){
                            this.errorMessage='Invalid sequence: sequence is empty after cleaning.';
                            return;
                        }
                        
                        console.log('Full sequence length:', fullSequence.length);
                        
                        // Parse NetMHCIIpan output file directly (matching Python logic)
                        this.epitopeProcessing.value = 30;
                        console.log('Parsing NetMHCIIpan file...');
                        const epitopeDf = this.parseNetMhcToDf(this.netmhciiFileContent);
                        console.log('Parsed epitopes:', epitopeDf ? epitopeDf.length : 0);
                        
                        if(!epitopeDf || !epitopeDf.length){ 
                            this.errorMessage='No epitopes found in NetMHCIIpan output file. Please check the file format.'; 
                            return; 
                        }
                        
                        // Step 1: Filter by binding strength
                        this.epitopeProcessing.value = 50;
                        console.log('Filtering epitopes by binding strength...');
                        const filtered = this.filterEpitopesByBinding(epitopeDf, this.analysisMode);
                        console.log('Filtered epitopes:', filtered ? filtered.length : 0);
                        if(!filtered || !filtered.length){
                            this.errorMessage='No epitopes selected after filtering. Try adjusting Top N epitopes or check your NetMHCIIpan file.';
                            return;
                        }
                        
                        // Step 2: Extend core sequences to target length
                        this.epitopeProcessing.value = 70;
                        console.log('Extending core sequences...');
                        const extended = this.extendCores(filtered, fullSequence, this.epitopeLength);
                        console.log('Extended epitopes:', extended ? extended.length : 0);
                        this.advancedEpitopes = extended; 
                        this.errorMessage='';
                        console.log('Analysis completed successfully!');
                    }catch(e){ 
                        console.error('Epitopes identification error:', e);
                        console.error('Error stack:', e.stack);
                        this.errorMessage = e.message || 'Epitopes identification failed: ' + String(e); 
                    }
                    finally { 
                        try{ 
                            if(this._epiTimer){ 
                                clearInterval(this._epiTimer); 
                                this._epiTimer=null; 
                            } 
                            this.epitopeProcessing.value=100; 
                            setTimeout(()=>{ 
                                this.epitopeProcessing.active=false; 
                                this.epitopeProcessing.value=0; 
                            }, 300);
                        }catch(_){} 
                    }
                },
                exportAdvancedEpitopes(){ if(!this.advancedEpitopes || !this.advancedEpitopes.length) return; const header=['sequence','start','end','core','allele','score','rank_el','rank','ic50','number_of_strong_binding']; const rows=this.advancedEpitopes.map(r=>header.map(h=>r[h]!==undefined?r[h]:'').join(',')); const csv=[header.join(','), ...rows].join('\n'); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='selected_epitopes.csv'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); },
                parseNetMhcToDf(text){
                    const rows = [];
                    const lines = text.split('\n').filter(l => l.trim());
                    
                    if (lines.length < 2) return rows;
                    
                    // Detect format: wide-table format has HLA allele names in first row
                    const firstLine = lines[0].toUpperCase();
                    const isWideFormat = firstLine.includes('HLA-') || firstLine.includes('DRB1_') || firstLine.includes('DRB1*');
                    
                    if (isWideFormat && lines.length >= 3) {
                        // Parse wide-table format (Excel format)
                        return this.parseWideTableFormat(lines);
                    } else {
                        // Parse standard format
                        return this.parseStandardFormat(lines);
                    }
                },
                parseWideTableFormat(lines){
                    const rows = [];
                    
                    // Extract HLA alleles from first line (header)
                    const headerLine = lines[0].trim();
                    const headerParts = headerLine.split(/\t+/);
                    const hlaAlleles = [];
                    
                    for (let i = 0; i < headerParts.length; i++) {
                        const part = headerParts[i].trim();
                        if (part && (part.includes('HLA-') || part.includes('DRB1_') || part.includes('DRB1*'))) {
                            // Normalize allele name
                            let allele = part;
                            if (part.includes('DRB1_')) {
                                // Convert DRB1_0101 to DRB1*01:01
                                const match = part.match(/DRB1_(\d{2})(\d{2})/);
                                if (match) {
                                    allele = `DRB1*${match[1]}:${match[2]}`;
                                }
                            }
                            hlaAlleles.push(allele);
                        }
                    }
                    
                    if (hlaAlleles.length === 0) {
                        console.warn('No HLA alleles found in header');
                        return rows;
                    }
                    
                    // Find data start (skip header lines)
                    let dataStartIdx = 2;
                    while (dataStartIdx < lines.length && 
                           (lines[dataStartIdx].trim().startsWith('#') || 
                            lines[dataStartIdx].trim() === '')) {
                        dataStartIdx++;
                    }
                    
                    // Each HLA has 7 columns: Core, Inverted, Score, Rank, Score_BA, nM, Rank_BA
                    const colsPerAllele = 7;
                    const dataStartCol = 4; // After Pos, Peptide, ID, Target
                    
                    // Parse data rows
                    for (let lineIdx = dataStartIdx; lineIdx < lines.length; lineIdx++) {
                        const line = lines[lineIdx].trim();
                        if (!line || line.startsWith('#')) continue;
                        
                        const parts = line.split(/\t+/);
                        if (parts.length < 5) continue;
                        
                        try {
                            const pos = parseInt(parts[0]);
                            const peptide = parts[1] || '';
                            const seqId = parts[2] || 'Sequence';
                            
                            if (!peptide || isNaN(pos)) continue;
                            
                            // Process each HLA allele
                            for (let i = 0; i < hlaAlleles.length; i++) {
                                const allele = hlaAlleles[i];
                                const alleleStartCol = dataStartCol + (i * colsPerAllele);
                                
                                if (alleleStartCol + 6 < parts.length) {
                                    try {
                                        const core = parts[alleleStartCol] || peptide;
                                        const score = parseFloat(parts[alleleStartCol + 2]) || null;
                                        const rank = parseFloat(parts[alleleStartCol + 3]) || null;
                                        const scoreBa = parseFloat(parts[alleleStartCol + 4]) || null;
                                        const nm = parseFloat(parts[alleleStartCol + 5]) || null;
                                        const rankBa = parseFloat(parts[alleleStartCol + 6]) || null;
                                        
                                        const start = pos;
                                        const end = start + peptide.length - 1;
                                        
                                        rows.push({
                                            sequence: peptide,
                                            core: (core && core !== 'NA' && core !== '') ? core : peptide,
                                            start: start,
                                            end: end,
                                            score: score || scoreBa || 0,
                                            rank_el: rank,  // %Rank_EL
                                            rank: rankBa,   // BA_Rank
                                            ic50: nm,
                                            raw_score: scoreBa,
                                            allele: allele,
                                            seq_id: seqId
                                        });
                                    } catch (e) {
                                        continue;
                                    }
                                }
                            }
                        } catch (e) {
                            continue;
                        }
                    }
                    
                    console.log(`Parsed ${rows.length} epitopes from wide-table format`);
                    return rows;
                },
                parseStandardFormat(lines){
                    const rows = [];
                    for (const raw of lines) {
                        const line = raw.trim();
                        if (!line || line.startsWith('#')) continue;
                        
                        const parts = line.split(/\s+|\t+/).filter(Boolean);
                        if (parts.length < 5) continue;
                        
                        try {
                            const pos = parseInt(parts[0]);
                            const peptide = parts[1] || '';
                            const allele = (parts[2] || '').includes('*') ? parts[2] : (parts[3] || '-');
                            
                            if (!peptide || isNaN(pos)) continue;
                            
                            let rank = null, ic50 = null, score = null;
                            for (let j = 3; j < parts.length; j++) {
                                const v = parseFloat(parts[j]);
                                if (!isNaN(v)) {
                                    if (v >= 0 && v <= 100 && rank === null) rank = v;
                                    else if (v > 1 && v < 100000 && ic50 === null) ic50 = v;
                                    else if (score === null) score = v;
                                }
                            }
                            
                            const core = (parts[4] && parts[4].length <= 15) ? parts[4] : peptide;
                            const start = isFinite(pos) ? pos : 1;
                            const end = start + peptide.length - 1;
                            
                            rows.push({
                                sequence: peptide,
                                core: core,
                                start: start,
                                end: end,
                                score: score || 0,
                                rank_el: rank,
                                rank: rank,
                                ic50: ic50,
                                allele: allele,
                                seq_id: parts[2] || ''
                            });
                        } catch (e) {
                            continue;
                        }
                    }
                    return rows;
                },
                filterEpitopesByBinding(epiRows, mode){
                    // Ensure core column exists (matching Python logic)
                    const withCore = epiRows.map(r => ({
                        ...r,
                        core: r.core || r.sequence
                    }));
                    
                    // Determine which rank column to use (priority: rank_el > rank)
                    // Strong binding: rank <= 1.0
                    // Weak binding: 1.0 < rank <= 5.0
                    const byCore = new Map();
                    
                    for (const r of withCore) {
                        const rankValue = (r.rank_el != null && !isNaN(r.rank_el)) 
                            ? parseFloat(r.rank_el) 
                            : ((r.rank != null && !isNaN(r.rank)) ? parseFloat(r.rank) : null);
                        
                        let bindingClass = null;
                        if (rankValue != null) {
                            if (rankValue <= 1.0) {
                                bindingClass = 'strong';
                            } else if (rankValue <= 5.0) {
                                bindingClass = 'weak';
                            }
                        }
                        
                        if (!byCore.has(r.core)) {
                            byCore.set(r.core, {strong: 0, weak: 0});
                        }
                        
                        if (bindingClass === 'strong') {
                            byCore.get(r.core).strong++;
                        } else if (bindingClass === 'weak') {
                            byCore.get(r.core).weak++;
                        }
                    }
                    
                    // Calculate number_of_strong_binding = strong + weak for each core
                    const counts = [...byCore.entries()].map(([core, c]) => ({
                        core: core,
                        number_of_strong_binding: c.strong + c.weak
                    }));
                    
                    // Sort by number_of_strong_binding (descending)
                    counts.sort((a, b) => b.number_of_strong_binding - a.number_of_strong_binding);
                    
                    // Select top N (reduce) or bottom N (enhance)
                    const N = this.epitopesNumber || 10;
                    const selected = (mode === 'reduce') 
                        ? counts.slice(0, N).map(x => x.core)
                        : counts.slice(Math.max(0, counts.length - N)).map(x => x.core);
                    
                    // Create map for quick lookup
                    const mapCount = new Map(counts.map(x => [x.core, x.number_of_strong_binding]));
                    
                    // Filter: only include records with strong or weak binding (rank <= 5.0)
                    // and add binding count information
                    return withCore
                        .filter(r => {
                            // First check if core is selected
                            if (!selected.includes(r.core)) {
                                return false;
                            }
                            
                            // Then check if this specific record has strong or weak binding
                            const rankValue = (r.rank_el != null && !isNaN(r.rank_el)) 
                                ? parseFloat(r.rank_el) 
                                : ((r.rank != null && !isNaN(r.rank)) ? parseFloat(r.rank) : null);
                            
                            if (rankValue == null) {
                                return false; // No rank value, exclude
                            }
                            
                            // Only include strong binding (<= 1.0) or weak binding (1.0 < rank <= 5.0)
                            return rankValue <= 5.0;
                        })
                        .map(r => ({
                            ...r,
                            number_of_strong_binding: mapCount.get(r.core) || 0
                        }));
                },
                extendCores(rows, fullSequence, targetLen){
                    // Validate target length (9-15 aa)
                    const t = (targetLen >= 9 && targetLen <= 15) ? targetLen : 15;
                    const seqLength = fullSequence.length;
                    
                    console.log(`Extending cores to target length: ${t} aa`);
                    
                    return rows.map((r, idx) => {
                        const coreSeq = r.core || r.sequence;
                        const peptideSeq = r.sequence || '';
                        const coreLen = coreSeq.length;
                        
                        // Find core position within peptide
                        let coreStartInPeptide = 0;
                        let coreEndInPeptide = coreLen - 1;
                        
                        if (coreSeq !== peptideSeq && peptideSeq.length > 0) {
                            // Try to find core within peptide
                            const coreIndex = peptideSeq.indexOf(coreSeq);
                            if (coreIndex >= 0) {
                                coreStartInPeptide = coreIndex;
                                coreEndInPeptide = coreIndex + coreLen - 1;
                            } else {
                                // If core not found, assume it's at the center
                                coreStartInPeptide = Math.floor((peptideSeq.length - coreLen) / 2);
                                coreEndInPeptide = coreStartInPeptide + coreLen - 1;
                            }
                        }
                        
                        // Calculate core position in full sequence (1-based)
                        const peptideStart = parseInt(r.start) || 1;
                        const coreStart = peptideStart + coreStartInPeptide;
                        const coreEnd = coreStart + coreLen - 1;
                        
                        // If core is already at or above target length, keep as is
                        if (coreLen >= t) {
                            console.log(`Core ${idx + 1}: ${coreSeq} (${coreLen}aa) already >= target (${t}aa), keeping unchanged`);
                            return {
                                ...r,
                                sequence: coreSeq,
                                start: coreStart,
                                end: coreEnd
                            };
                        }
                        
                        // Calculate extension needed
                        const extensionNeeded = t - coreLen;
                        const maxForward = Math.min(2, extensionNeeded);
                        const maxBackward = Math.min(4, extensionNeeded - maxForward);
                        
                        // Calculate new start and end positions (1-based) based on core position
                        const newStart = Math.max(1, coreStart - maxForward);
                        const newEnd = Math.min(seqLength, coreEnd + maxBackward);
                        
                        // Ensure we don't exceed target length
                        const actualLength = newEnd - newStart + 1;
                        let finalEnd = newEnd;
                        if (actualLength > t) {
                            // If we exceed target, trim from the end
                            finalEnd = newStart + t - 1;
                        }
                        
                        // Extract extended sequence from full sequence
                        const extendedSeq = fullSequence.substring(newStart - 1, finalEnd);
                        const extractedLength = extendedSeq.length;
                        
                        console.log(`Core ${idx + 1}: ${coreSeq} (${coreLen}aa) at [${coreStart}-${coreEnd}] -> ${extendedSeq} (${extractedLength}aa) at [${newStart}-${finalEnd}]`);
                        console.log(`  Target: ${t}aa, Extension needed: ${extensionNeeded}aa (forward ${maxForward}aa, backward ${maxBackward}aa), actual length: ${extractedLength}aa`);
                        
                        if (extractedLength > t) {
                            console.warn(`  Warning: Length ${extractedLength}aa exceeds target ${t}aa!`);
                        } else if (extractedLength === t) {
                            console.log(`  Success: Extended to target length ${t}aa`);
                        } else if (extractedLength < t) {
                            console.log(`  Note: Extended to ${extractedLength}aa (target ${t}aa) - sequence boundary reached`);
                        }
                        
                        return {
                            ...r,
                            sequence: extendedSeq,
                            start: newStart,
                            end: finalEnd
                        };
                    });
                },
                // wy2 (run_ic50_sum)
                handleWy2Csv(evt){ 
                    try {
                        const file = evt.target.files && evt.target.files[0];
                        if (!file) return;
                        this.wy2CsvName = file.name;
                        this.errorMessage = '';
                        
                        const fileName = file.name.toLowerCase();
                        if (fileName.endsWith('.txt') || fileName.endsWith('.csv')) {
                            // Handle text file
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                this.wy2CsvText = (e.target.result || '').toString();
                            };
                            reader.readAsText(file, 'utf-8');
                        } else if (fileName.endsWith('.xls') || fileName.endsWith('.xlsx')) {
                            // Handle Excel file
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                try {
                                    const data = new Uint8Array(e.target.result);
                                    const workbook = XLSX.read(data, { type: 'array' });
                                    
                                    // Convert Excel to text format (tab-separated)
                                    const textContent = this.convertExcelToNetMHCIIFormat(workbook);
                                    if (textContent) {
                                        this.wy2CsvText = textContent;
                                    } else {
                                        this.errorMessage = 'Failed to parse Excel file. Please check the file format.';
                                    }
                                } catch (excelError) {
                                    console.error('Excel parsing error:', excelError);
                                    this.errorMessage = 'Failed to parse Excel file: ' + (excelError.message || 'Unknown error');
                                }
                            };
                            reader.readAsArrayBuffer(file);
                        } else {
                            this.errorMessage = 'Unsupported file format. Please use .txt, .csv, .xls, or .xlsx files.';
                        }
                    } catch (e) {
                        this.errorMessage = e.message || 'File read failed';
                    }
                },
                processWy2(){ try{ 
                    // start progress
                    this.wy2Processing.active = true; this.wy2Processing.value = 10;
                    if (this._wy2Timer) { clearInterval(this._wy2Timer); this._wy2Timer=null; }
                    this._wy2Timer = setInterval(()=>{ if (this.wy2Processing.value < 90) this.wy2Processing.value += 5; }, 150);
                    const parsed=this.parseTwoHeaderCsv(this.wy2CsvText); const {headerAlleles, headerFields, dataRows}=parsed; const ic50Map=new Map(); let currentAllele=null; for(let i=0;i<headerFields.length;i++){ const aRaw=headerAlleles[i]||''; const fRaw=headerFields[i]||''; if(aRaw && /^DRB1_/i.test(aRaw)) currentAllele=this.normalizeAllele(aRaw); if(/^nM$/i.test(fRaw) && currentAllele){ const series=dataRows.map(r=> Number(r[i])); ic50Map.set(currentAllele, series); } } const peptides=this.extractPeptidesColumn(headerAlleles, headerFields, dataRows); const idCol=this.extractIdColumn(headerAlleles, headerFields, dataRows); const alleleList=[...ic50Map.keys()]; const scores=dataRows.map(()=>0); const bestIc50=dataRows.map(()=>Infinity); const alleleCounts=dataRows.map(()=>0); for(const allele of alleleList){ const arr=ic50Map.get(allele); const idxs=arr.map((v,i)=>({i,v})).filter(x=>Number.isFinite(x.v)); idxs.sort((a,b)=> a.v - b.v); const ranks=new Array(arr.length).fill(NaN); for(let rank=1; rank<=idxs.length; rank++){ ranks[idxs[rank-1].i]=rank; } const minR=1; const maxR=idxs.length||1; const denom=(maxR - minR)||1; for(let i=0;i<arr.length;i++){ const r=ranks[i]; if(Number.isFinite(r)){ const score=((r - minR)/denom)*100.0; scores[i]+= (this.wy2Mode==='reduce' ? (100.0 - score) : score); bestIc50[i]=Math.min(bestIc50[i], arr[i]); alleleCounts[i]+=1; } } }
                    const rows=scores.map((s,i)=>({ Peptide: peptides[i] || `pep_${i}`, ID: idCol ? idCol[i] : undefined, Allele_Count: alleleCounts[i], Best_IC50: Number.isFinite(bestIc50[i])?Number(bestIc50[i].toFixed(2)):undefined, Overall: Number(s.toFixed(3)) })); 
                    // Sort by mode: reduce (ascending, lower is better), enhance (descending, higher is better)
                    rows.sort((a,b)=> this.wy2Mode==='reduce' ? (a.Overall - b.Overall) : (b.Overall - a.Overall));
                    // Add rank after sorting
                    rows.forEach((r,idx)=> r.Rank = idx + 1);
                    this.wy2Peptides=rows; if(idCol){ const agg=new Map(); for(const r of rows){ const id=r.ID==null?'':String(r.ID); if(!agg.has(id)) agg.set(id,0); agg.set(id, agg.get(id)+r.Overall); } this.wy2Seqsum=[...agg.entries()].map(([ID,score])=>({ID, score:Number(score.toFixed(3))})).sort((a,b)=> a.score - b.score); } else { this.wy2Seqsum=[]; } this.errorMessage=''; }catch(e){ this.errorMessage=e.message||'wy2 processing failed'; } finally { try{ if(this._wy2Timer){ clearInterval(this._wy2Timer); this._wy2Timer=null; } this.wy2Processing.value=100; setTimeout(()=>{ this.wy2Processing.active=false; this.wy2Processing.value=0; }, 300); }catch(_){} } },
                exportWy2(){ if(!this.wy2Peptides||!this.wy2Peptides.length) return; const header=['Rank','Peptide','ID','Allele_Count','Best_IC50(nM)','S^im_Score']; const rows=this.wy2Peptides.map(r=>[r.Rank ?? '', r.Peptide, r.ID ?? '', r.Allele_Count ?? '', r.Best_IC50 ?? '', r.Overall ?? '']); const csv=[header.join(','), ...rows.map(x=>x.join(','))].join('\n'); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`sim_im_${this.wy2Mode}.csv`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); },
                exportWy2Seqsum(){ if(!this.wy2Seqsum||!this.wy2Seqsum.length) return; const header=['ID','S^im_score']; const rows=this.wy2Seqsum.map(r=>[r.ID, r.score]); const csv=[header.join(','), ...rows.map(x=>x.join(','))].join('\n'); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`sim_im_${this.wy2Mode}_seqsum.csv`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); },
                exportWy2Combined(){
                    if(!this.wy2Peptides||!this.wy2Peptides.length) return;
                    const header = ['Rank','Peptide','ID','Allele_Count','Best_IC50(nM)','S^im_Score'];
                    const rows = this.wy2Peptides.map(r=>[r.Rank ?? '', r.Peptide, r.ID ?? '', r.Allele_Count ?? '', r.Best_IC50 ?? '', r.Overall ?? '']);
                    const csv = [header.join(','), ...rows.map(x=>x.join(','))].join('\n');
                    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `sim_im_${this.wy2Mode}_combined.csv`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                },
                parseTwoHeaderCsv(text){ const lines=text.replace(/\r\n/g,'\n').replace(/\r/g,'\n').split('\n').filter(x=>x.trim().length>0); if(lines.length<3) throw new Error('Need at least two header rows and one data row'); const sep=(lines[0].includes('\t')||lines[1].includes('\t'))?'\t':','; const headerAlleles=lines[0].split(sep).map(s=>s.trim()); const headerFields=lines[1].split(sep).map(s=>s.trim()); const dataRows=lines.slice(2).map(l=>l.split(sep).map(s=>s.trim())); return {headerAlleles, headerFields, dataRows}; },
                normalizeAllele(a){ try{ const code=a.split('_')[1]; return `DRB1*${code.slice(0,2)}:${code.slice(2)}`; }catch(_){ return a; } },
                extractPeptidesColumn(headerAlleles, headerFields, dataRows){ for(let i=0;i<headerFields.length;i++) if(headerAlleles[i]==='' && /^peptide$/i.test(headerFields[i])) return dataRows.map(r=>r[i]); return dataRows.map(r=>r[1]||''); },
                extractIdColumn(headerAlleles, headerFields, dataRows){ for(let i=0;i<headerFields.length;i++) if(headerAlleles[i]==='' && /^id$/i.test(headerFields[i])) return dataRows.map(r=>r[i]); return null; },
                async loadStructureExampleLow() {
                    try {
                        this.isRefLoading = true;
                        this.isPredLoading = true;
                        // Make names visible, delay loading content to calculation (like CSV flow)
                        this.referenceFileName = 'example_1_ref.pdb';
                        this.predictedFileName = 'example_1_pred.pdb';
                        this.referencePdbContent = '';
                        this.predictedPdbContent = '';
                        this.referenceFileObj = null;
                        this.predictedFileObj = null;
                        this.useEmbeddedRef = true;
                        this.useEmbeddedPred = true;
                        this.embeddedRefId = 'pdb_6htx';
                        this.embeddedPredId = 'pdb_6htx_var';
                        this.rmsdResult = null;
                        this.rmsdError = '';
                        this.showRmsdResult = false;
                        this.scrollTo('structure');
                    } catch (e) {
                        this.rmsdError = e.message || 'Failed to load example';
                    } finally {
                        this.isRefLoading = false;
                        this.isPredLoading = false;
                    }
                }
                ,
                async loadStructureExampleHigh() {
                    try {
                        this.isRefLoading = true;
                        this.isPredLoading = true;
                        // Like CSV flow: only show names; delay constructing content/files to calculation
                        this.referenceFileName = 'example_1_ref.pdb';
                        this.referencePdbContent = '';
                        this.referenceFileObj = null;
                        this.useEmbeddedRef = true;
                        this.embeddedRefId = 'pdb_6htx';
                        this.predictedFileName = 'example_2_pred.pdb';
                        this.predictedPdbContent = '';
                        this.predictedFileObj = null;
                        this.useEmbeddedPred = true;
                        this.embeddedPredId = 'pdb_6htx_far';

                        this.rmsdResult = null;
                        this.rmsdError = '';
                        this.showRmsdResult = false;
                        this.scrollTo('structure');
                    } catch (e) {
                        this.rmsdError = e.message || 'Failed to load example';
                    } finally {
                        this.isRefLoading = false;
                        this.isPredLoading = false;
                    }
                }
            },
            mounted() {
                // Initialize page view counter
                this.initPageViews();
                
                window.addEventListener('scroll', () => {
                    const sections = ['epitope', 'analyze', 'structure', 'docs', 'cite'];
                    for (const sec of sections) {
                        const el = document.getElementById(sec);
                        if (el) {
                            const rect = el.getBoundingClientRect();
                            if (rect.top <= 100 && rect.bottom >= 100) {
                                this.currentSection = sec;
                                break;
                            }
                        }
                    }
                });
            }
        });
    </script>
</body>
</html>
