<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Circular Contact Map - Toolboxes</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet" />
  <style>
    body { background: #f7f9fc; }
    .container-narrow { max-width: 960px; }
    .card { border: 1px solid #e7eaf0; box-shadow: 0 6px 16px rgba(0,0,0,0.06); }
    code { background:#f4f4f4; padding:2px 6px; border-radius:3px; }
  </style>
  <script defer src="https://buttons.github.io/buttons.js"></script>
  <script>
    function downloadScript() {
      window.location.href = '../scripts/circular_ribbon_contact_map.py';
    }
  </script>
  <meta name="description" content="Circular ribbon contact map generator for nanobody–antigen interface analysis." />
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-chord@3"></script>
</head>
<body>
  <div class="container container-narrow py-4">
    <div class="text-center mb-4">
      <h1 class="fw-bold"><i class="fas fa-circle-notch"></i> Circular Contact Map</h1>
      <p class="text-muted m-0">Nanobody–antigen interface analysis with circular ribbon diagrams</p>
      <a class="github-button" href="https://github.com/RuijinHospitalVNAR/Toolboxes" data-size="large" data-show-count="true" aria-label="Star">Star</a>
    </div>

    <div class="card mb-3">
      <div class="card-body">
        <h5 class="card-title">What is this tool?</h5>
        <p class="card-text">
          This tool helps you generate a <strong>circular ribbon contact map</strong> to visualize
          residue–residue contacts between two protein chains (e.g., nanobody and antigen).
          It supports two workflows:
        </p>
        <ol>
          <li><strong>From mmCIF</strong>: extract sequences and contacts for two chains, then plot.</li>
          <li><strong>From edges.csv</strong>: directly plot from a Cytoscape-like <code>edges.csv</code> (source,target[,distance]).</li>
        </ol>
      </div>
    </div>

    <div class="card mb-3">
      <div class="card-body">
        <h5 class="card-title">Download</h5>
        <p class="card-text">Run locally with Python. Requires <code>pandas</code>, <code>holoviews[bokeh]</code>, <code>biopython</code>.</p>
        <button class="btn btn-primary" onclick="downloadScript()"><i class="fas fa-download"></i> Download Python script</button>
        <a class="btn btn-outline-secondary ms-2" target="_blank" href="../scripts/circular_ribbon_contact_map.py"><i class="fas fa-file-code"></i> View source</a>
        <p class="small text-muted mt-2">File: <code>scripts/circular_ribbon_contact_map.py</code></p>
      </div>
    </div>

    <div class="card mb-3">
      <div class="card-body">
        <h5 class="card-title">Quick start</h5>
        <p class="mb-1 fw-bold">Install dependencies</p>
        <pre class="mb-3"><code>pip install pandas holoviews bokeh biopython matplotlib</code></pre>
        <p class="mb-1 fw-bold">A) From mmCIF (recommended)</p>
        <pre class="mb-3"><code>python scripts/circular_ribbon_contact_map.py --cif complex.cif --chain1 H --chain2 L --cutoff 5.0 --output H_L_contact_map.html</code></pre>
        <ul>
          <li>Outputs sequences (FASTA), contact pairs (CSV), and an HTML plot (interactive).</li>
          <li>Use <code>--output &lt;file.png&gt;</code> to render PNG (requires bokeh + selenium + pillow).</li>
        </ul>
        <p class="mb-1 fw-bold">B) From edges.csv</p>
        <pre class="mb-0"><code># edges.csv columns: source,target[,distance]
python scripts/circular_ribbon_contact_map.py edges.csv --output contact_map.html</code></pre>
      </div>
    </div>

    <div class="card mb-3">
      <div class="card-body">
        <h5 class="card-title">Tips</h5>
        <ul class="mb-0">
          <li>Residue node naming format: <code>Chain_RES3_Num</code> (e.g., <code>A_ARG_100</code>).</li>
          <li>Distance (optional) can control edge width; closer contacts draw thicker ribbons.</li>
          <li>Recommended distance cutoff for contacts: 4.5–5.0 Å.</li>
        </ul>
      </div>
    </div>

    <!-- Web App: upload & draw chord -->
    <div class="card mb-3">
      <div class="card-body">
        <h5 class="card-title">Web app (no backend) — Upload and draw</h5>
        <p class="text-muted">Upload one of the following: <code>edges.csv</code>, <code>edges.json</code>, or <code>.cif</code>. For CIF, choose two chains and cutoff.</p>
        <div class="row g-3 align-items-end">
          <div class="col-md-6">
            <label class="form-label">Upload file (csv/json/cif)</label>
            <input id="fileInput" type="file" class="form-control" accept=".csv,.json,.cif" />
          </div>
          <div class="col-md-2">
            <label class="form-label">Chain 1</label>
            <select id="chain1" class="form-select"></select>
          </div>
          <div class="col-md-2">
            <label class="form-label">Chain 2</label>
            <select id="chain2" class="form-select"></select>
          </div>
          <div class="col-md-2">
            <label class="form-label">Cutoff (Å)</label>
            <input id="cutoff" type="number" class="form-control" value="5.0" min="3.0" max="10.0" step="0.1" />
          </div>
          <div class="col-md-12">
            <div class="form-check mt-2">
              <input class="form-check-input" type="checkbox" value="" id="useWeighting" />
              <label class="form-check-label" for="useWeighting">
                Use distance weighting (closer contacts → thicker ribbons)
              </label>
            </div>
          </div>
        </div>
        <div class="mt-3">
          <button id="btnParse" class="btn btn-primary"><i class="fas fa-play"></i> Parse & Draw</button>
          <button id="btnExport" class="btn btn-outline-success ms-2" style="display:none;"><i class="fas fa-download"></i> Export Sequences & Contacts</button>
          <small id="status" class="text-muted ms-2"></small>
        </div>
        <div class="mt-4" id="vizContainer">
          <svg id="chordSvg" width="760" height="760"></svg>
          <div class="mt-3" id="legendBox">
            <div class="small text-muted mb-2"><i class="fas fa-info-circle"></i> <strong>Legend:</strong></div>
            <div class="small">
              <div class="mb-1"><strong>Node colors:</strong> Based on amino acid properties</div>
              <div class="d-flex flex-wrap gap-2 mb-2">
                <span><span style="display:inline-block;width:12px;height:12px;background:#FF7744;border:1px solid #ccc;"></span> Hydrophobic (ALA, VAL, LEU, ILE, MET, PHE, TRP, PRO, GLY)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#87CEFA;border:1px solid #ccc;"></span> Polar (SER, THR, TYR, ASN, GLN)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#FF0000;border:1px solid #ccc;"></span> Acidic (ASP, GLU)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#B565A7;border:1px solid #ccc;"></span> Basic (LYS, ARG, HIS)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#000000;border:1px solid #ccc;"></span> Cysteine (CYS)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#FFA500;border:1px solid #ccc;"></span> Chain 1 (unconnected)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#20B2AA;border:1px solid #ccc;"></span> Chain 2 (unconnected)</span>
              </div>
              <div class="mb-1"><strong>Ribbon colors:</strong> Based on source node amino acid properties</div>
              <div class="mb-1"><strong>Ribbon thickness:</strong> When "Use distance weighting" is enabled, closer contacts contribute more weight; otherwise each contact contributes equally.</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="text-center text-muted mt-4">
      <small>&copy; 2025 Toolboxes. MIT License.</small>
    </div>
  </div>
  <script>
    // Amino acid property classification (matching Python version)
    const hydrophobic = new Set(['ALA', 'VAL', 'LEU', 'ILE', 'MET', 'PHE', 'TRP', 'PRO', 'GLY']);
    const polar = new Set(['SER', 'THR', 'TYR', 'ASN', 'GLN']);
    const acidic = new Set(['ASP', 'GLU']);
    const basic = new Set(['LYS', 'ARG', 'HIS']);
    
    // Color mapping (matching Python version with alpha 0.75)
    function getAAColor(resname) {
      const res = resname.toUpperCase();
      if (res === 'CYS') return '#000000'; // black
      if (hydrophobic.has(res)) return '#FF7744'; // orange-red
      if (polar.has(res)) return '#87CEFA'; // light blue
      if (acidic.has(res)) return '#FF0000'; // red
      if (basic.has(res)) return '#B565A7'; // purple
      return '#AAAAAA'; // default gray
    }
    
    // Extract residue name from node label (format: Chain_RES3_Num)
    function extractResname(nodeLabel) {
      const parts = nodeLabel.split('_');
      if (parts.length >= 2) return parts[1];
      return null;
    }
    
    // Extract chain ID from node label
    function extractChain(nodeLabel) {
      const parts = nodeLabel.split('_');
      if (parts.length >= 1) return parts[0];
      return null;
    }
    
    // Get node color based on amino acid property or chain (for unconnected nodes)
    function getNodeColor(nodeLabel, connectedNodes, chain1, chain2) {
      if (connectedNodes.has(nodeLabel)) {
        const resname = extractResname(nodeLabel);
        if (resname) return getAAColor(resname);
      }
      // Unconnected nodes: color by chain
      const chain = extractChain(nodeLabel);
      if (chain === chain1) return '#FFA500'; // orange for chain1
      if (chain === chain2) return '#20B2AA'; // teal for chain2
      return 'rgba(0,0,0,0.4)'; // default gray
    }
    
    // Get edge color based on source node amino acid property
    function getEdgeColor(sourceNode) {
      const resname = extractResname(sourceNode);
      if (resname) return getAAColor(resname);
      return '#AAAAAA'; // default gray
    }
    
    // Extract sequence from CA rows
    function extractSequence(caRows, chainId) {
      const chainResidues = caRows.filter(r => r.chain === chainId);
      // Sort by residue number
      chainResidues.sort((a, b) => a.resnum - b.resnum);
      // Get unique residues (in case of duplicates)
      const seen = new Set();
      const unique = [];
      for (const r of chainResidues) {
        const key = `${r.resnum}_${r.resname}`;
        if (!seen.has(key)) {
          seen.add(key);
          unique.push(r);
        }
      }
      return unique.map(r => r.resname);
    }
    
    // Three-letter to one-letter amino acid code
    const aa3to1 = {
      'ALA': 'A', 'CYS': 'C', 'ASP': 'D', 'GLU': 'E', 'PHE': 'F',
      'GLY': 'G', 'HIS': 'H', 'ILE': 'I', 'LYS': 'K', 'LEU': 'L',
      'MET': 'M', 'ASN': 'N', 'PRO': 'P', 'GLN': 'Q', 'ARG': 'R',
      'SER': 'S', 'THR': 'T', 'VAL': 'V', 'TRP': 'W', 'TYR': 'Y'
    };
    
    function resnameToSeq(resname) {
      return aa3to1[resname.toUpperCase()] || 'X';
    }
    
    // Identify interfaces (continuous residue segments)
    function identifyInterfaces(edges) {
      const contactNodes = new Set(edges.flatMap(e => [e.source, e.target]));
      const chainResnum = {};
      
      for (const node of contactNodes) {
        const parts = node.split('_');
        if (parts.length === 3) {
          const chain = parts[0];
          const num = parseInt(parts[2]);
          if (!isNaN(num)) {
            if (!chainResnum[chain]) chainResnum[chain] = [];
            chainResnum[chain].push(num);
          }
        }
      }
      
      const interfaces = [];
      for (const [chain, nums] of Object.entries(chainResnum)) {
        const sorted = [...new Set(nums)].sort((a, b) => a - b);
        let current = [];
        let lastNum = null;
        
        for (const num of sorted) {
          if (lastNum !== null && num === lastNum + 1) {
            current.push(num);
          } else {
            if (current.length >= 2) {
              interfaces.push({ chain, residues: [...current] });
            }
            current = [num];
          }
          lastNum = num;
        }
        if (current.length >= 2) {
          interfaces.push({ chain, residues: [...current] });
        }
      }
      
      return interfaces;
    }
    
    // Utilities
    function setStatus(msg) { document.getElementById('status').textContent = msg; }
    function parseCSV(text) {
      const lines = text.replace(/\r\n/g,'\n').split('\n').filter(x=>x.trim().length>0);
      const header = lines[0].split(',').map(s=>s.trim());
      const idxS = header.findIndex(h=>/^source$/i.test(h));
      const idxT = header.findIndex(h=>/^target$/i.test(h));
      const idxD = header.findIndex(h=>/^distance$/i.test(h));
      if (idxS<0 || idxT<0) throw new Error('CSV must contain source,target columns');
      const edges=[];
      for (let i=1;i<lines.length;i++){
        const parts = lines[i].split(',');
        const s = (parts[idxS]||'').trim();
        const t = (parts[idxT]||'').trim();
        if (!s||!t) continue;
        const d = idxD>=0 ? Number(parts[idxD]) : undefined;
        edges.push({source:s,target:t,distance:(Number.isFinite(d)?d:undefined)});
      }
      return edges;
    }
    function parseJSON(text){
      const data = JSON.parse(text);
      if (Array.isArray(data)) return data; // assume array of edges
      if (Array.isArray(data.edges)) return data.edges;
      throw new Error('JSON must be an array of edges or {edges:[...]}.');
    }
    // Simple CIF parser: read atom_site loop, collect CA rows per chain
    function parseCIF_CA(text){
      const lines = text.split(/\r?\n/);
      let inLoop=false; const headerCols={}; const rows=[];
      for(const raw of lines){
        const line = raw.trim(); if(!line) continue;
        if (line.startsWith('loop_')) { inLoop=false; for(const k in headerCols) delete headerCols[k]; continue; }
        if (line.startsWith('_atom_site.')) { inLoop=true; const name=line.replace('_atom_site.','').trim(); headerCols[name]=Object.keys(headerCols).length; continue; }
        if (inLoop && !line.startsWith('#')){
          const parts=line.split(/\s+/);
          const li=headerCols['label_atom_id'], ci=headerCols['label_asym_id'], ri=headerCols['label_seq_id'], xi=headerCols['Cartn_x'], yi=headerCols['Cartn_y'], zi=headerCols['Cartn_z'], rn=headerCols['label_comp_id'];
          if([li,ci,ri,xi,yi,zi,rn].some(v=>v==null)) continue;
          if (parts.length<=Math.max(li,ci,ri,xi,yi,zi,rn)) continue;
          if (parts[li]==='CA'){
            const rec={
              chain: parts[ci],
              resnum: Number(parts[ri]),
              resname: parts[rn],
              x: Number(parts[xi]), y: Number(parts[yi]), z: Number(parts[zi]),
            };
            if (Number.isFinite(rec.x) && Number.isFinite(rec.y) && Number.isFinite(rec.z)) rows.push(rec);
          }
        }
      }
      return rows; // [{chain,resnum,resname,x,y,z}]
    }
    function calcContactsFromCA(caRows, chain1, chain2, cutoff){
      const a = caRows.filter(r=>r.chain===chain1);
      const b = caRows.filter(r=>r.chain===chain2);
      const cutoff2 = cutoff*cutoff;
      const edges=[];
      for(const r1 of a){
        for(const r2 of b){
          const dx=r1.x-r2.x, dy=r1.y-r2.y, dz=r1.z-r2.z; const d2=dx*dx+dy*dy+dz*dz;
          if (d2<=cutoff2){
            const s=`${chain1}_${r1.resname}_${r1.resnum}`;
            const t=`${chain2}_${r2.resname}_${r2.resnum}`;
            edges.push({source:s,target:t,distance:Math.sqrt(d2)});
          }
        }
      }
      return edges;
    }
    // Chord rendering via d3 (with amino acid-based coloring)
    let currentEdges = null;
    let currentChain1 = null;
    let currentChain2 = null;
    
    function renderChord(edges, chain1, chain2){
      currentEdges = edges;
      currentChain1 = chain1;
      currentChain2 = chain2;
      
      const svg = d3.select('#chordSvg');
      svg.selectAll('*').remove();
      const width=760, height=760, innerRadius= Math.min(width, height)*0.5 - 80, outerRadius=innerRadius+10;
      const nodes = Array.from(new Set(edges.flatMap(e=>[e.source,e.target])));
      const index = new Map(nodes.map((n,i)=>[n,i]));
      const N = nodes.length; const matrix = Array.from({length:N},()=>Array(N).fill(0));
      const connectedNodes = new Set(edges.flatMap(e=>[e.source,e.target]));
      
      // Distance weighting setup
      const useW = document.getElementById('useWeighting').checked;
      const dvals = edges.map(e=>e.distance).filter(d=>Number.isFinite(d));
      const dmin = dvals.length? Math.min(...dvals): 0;
      const dmax = dvals.length? Math.max(...dvals): 1;
      function weight(e){
        if (!useW || !Number.isFinite(e.distance)) return 1.0;
        if (dmax<=dmin) return 1.0;
        // Map distance to [0.5, 5.0] (closer → thicker)
        const t = (e.distance - dmin) / (dmax - dmin);
        return 5.0 - 4.5*t; // 5.0 (close) .. 0.5 (far)
      }
      
      // Build edge color mapping (based on source node)
      // For each edge, store color based on source node
      // Since matrix is symmetric, we need to track which direction has which color
      const edgeColorMap = new Map();
      for(const e of edges){
        const i=index.get(e.source), j=index.get(e.target);
        if (i==null || j==null) continue;
        const w = weight(e);
        matrix[i][j] += w; matrix[j][i] += w;
        // Store edge color based on source node (direction from i to j)
        const color = getEdgeColor(e.source);
        edgeColorMap.set(`${i}-${j}`, color);
        // For reverse direction, we could use target color, but for consistency use source
        if (!edgeColorMap.has(`${j}-${i}`)) {
          edgeColorMap.set(`${j}-${i}`, color);
        }
      }
      
      // Helper function to get edge color for a chord
      function getChordColor(chord) {
        const srcIdx = chord.source.index;
        const tgtIdx = chord.target.index;
        // Try to find color based on source node of the chord
        // Check if there's an edge from source to target
        const color1 = edgeColorMap.get(`${srcIdx}-${tgtIdx}`);
        if (color1) return color1;
        // Otherwise use color from target to source
        const color2 = edgeColorMap.get(`${tgtIdx}-${srcIdx}`);
        if (color2) return color2;
        // Fallback: use color based on source node
        return getEdgeColor(nodes[srcIdx]);
      }
      
      const chord = d3.chord().padAngle(0.02).sortSubgroups(d3.descending)(matrix);
      const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
      const ribbon = d3.ribbon().radius(innerRadius);
      const g = svg.attr('viewBox', [-width/2, -height/2, width, height]).append('g');

      // Groups (nodes) - color by amino acid property or chain
      const group = g.append('g')
        .selectAll('g')
        .data(chord.groups)
        .join('g');
      group.append('path')
        .attr('d', arc)
        .attr('fill', d=>getNodeColor(nodes[d.index], connectedNodes, chain1, chain2))
        .attr('stroke', '#fff')
        .attr('stroke-width', 1);
      group.append('text')
        .each(d=>{d.angle=(d.startAngle+d.endAngle)/2;})
        .attr('dy','.35em')
        .attr('transform', d=>`rotate(${d.angle*180/Math.PI-90}) translate(${outerRadius+6}) ${d.angle>Math.PI?"rotate(180)":''}`)
        .attr('text-anchor', d=>d.angle>Math.PI?'end':null)
        .style('font-size','9px')
        .text(d=>nodes[d.index]);

      // Ribbons (edges) - color by source node amino acid property
      g.append('g')
        .attr('fill-opacity',0.85)
        .selectAll('path')
        .data(chord)
        .join('path')
        .attr('d', ribbon)
        .attr('fill', getChordColor)
        .attr('stroke', '#fff')
        .attr('stroke-width', 0.5);
      
      // Show export button if we have CIF data
      if (cachedCIF && chain1 && chain2) {
        document.getElementById('btnExport').style.display = 'inline-block';
      } else {
        document.getElementById('btnExport').style.display = 'none';
      }
    }

    // Wire UI
    const input = document.getElementById('fileInput');
    const sel1 = document.getElementById('chain1');
    const sel2 = document.getElementById('chain2');
    const cutoffEl = document.getElementById('cutoff');
    const useWeightingEl = document.getElementById('useWeighting');
    let cachedCIF = null; // store CA rows after parsing
    
    // Re-render when distance weighting option changes
    useWeightingEl.addEventListener('change', () => {
      if (currentEdges) {
        renderChord(currentEdges, currentChain1, currentChain2);
      }
    });

    input.addEventListener('change', async (e)=>{
      setStatus(''); sel1.innerHTML=''; sel2.innerHTML=''; cachedCIF=null;
      document.getElementById('btnExport').style.display = 'none';
      const file=e.target.files && e.target.files[0]; if(!file) return;
      const name=file.name.toLowerCase(); const buf=await file.text();
      try{
        if (name.endsWith('.csv')){
          const edges=parseCSV(buf); 
          // Try to detect chains from edges
          let c1 = null, c2 = null;
          if (edges.length > 0) {
            const chains = new Set(edges.flatMap(e => [
              extractChain(e.source), 
              extractChain(e.target)
            ]).filter(c => c));
            const chainArray = Array.from(chains);
            if (chainArray.length >= 2) {
              c1 = chainArray[0];
              c2 = chainArray[1];
            } else if (chainArray.length === 1) {
              c1 = chainArray[0];
            }
          }
          renderChord(edges, c1, c2); 
          setStatus(`Parsed ${edges.length} edges from CSV.`);
        } else if (name.endsWith('.json')){
          const edges=parseJSON(buf);
          // Try to detect chains from edges
          let c1 = null, c2 = null;
          if (edges.length > 0) {
            const chains = new Set(edges.flatMap(e => [
              extractChain(e.source), 
              extractChain(e.target)
            ]).filter(c => c));
            const chainArray = Array.from(chains);
            if (chainArray.length >= 2) {
              c1 = chainArray[0];
              c2 = chainArray[1];
            } else if (chainArray.length === 1) {
              c1 = chainArray[0];
            }
          }
          renderChord(edges, c1, c2); 
          setStatus(`Parsed ${edges.length} edges from JSON.`);
        } else if (name.endsWith('.cif')){
          const rows=parseCIF_CA(buf); cachedCIF=rows;
          const chains = Array.from(new Set(rows.map(r=>r.chain)));
          chains.forEach(c=>{ const o=document.createElement('option'); o.value=c; o.textContent=c; sel1.appendChild(o.cloneNode(true)); sel2.appendChild(o); });
          setStatus(`Parsed CIF: detected chains [${chains.join(', ')}]. Choose chains and click Parse & Draw.`);
        } else {
          setStatus('Unsupported file type.');
        }
      }catch(err){ setStatus('Parse error: '+err.message); }
    });
    document.getElementById('btnParse').addEventListener('click', ()=>{
      const file=input.files && input.files[0]; if(!file){ setStatus('Please upload a file first.'); return; }
      const name=file.name.toLowerCase();
      if (name.endsWith('.cif')){
        if(!cachedCIF){ setStatus('CIF not parsed.'); return; }
        const c1=sel1.value, c2=sel2.value; const cutoff=Number(cutoffEl.value)||5.0;
        if(!c1||!c2||c1===c2){ setStatus('Please choose two different chains.'); return; }
        const edges=calcContactsFromCA(cachedCIF, c1, c2, cutoff);
        renderChord(edges, c1, c2); 
        const interfaces = identifyInterfaces(edges);
        let msg = `Computed ${edges.length} contacts @ cutoff ${cutoff} Å.`;
        if (interfaces.length > 0) {
          msg += ` Found ${interfaces.length} interface segment(s).`;
        }
        setStatus(msg);
      }
    });
    
    // Export sequences and contacts
    document.getElementById('btnExport').addEventListener('click', ()=>{
      if (!cachedCIF || !currentChain1 || !currentChain2) {
        setStatus('No CIF data available for export.');
        return;
      }
      
      try {
        // Extract sequences
        const seq1 = extractSequence(cachedCIF, currentChain1);
        const seq2 = extractSequence(cachedCIF, currentChain2);
        const seq1Str = seq1.map(r => resnameToSeq(r)).join('');
        const seq2Str = seq2.map(r => resnameToSeq(r)).join('');
        
        // Export FASTA files
        const fasta1 = `>${currentChain1}\n${seq1Str}`;
        const fasta2 = `>${currentChain2}\n${seq2Str}`;
        
        downloadText(`${currentChain1}_sequence.fasta`, fasta1);
        downloadText(`${currentChain2}_sequence.fasta`, fasta2);
        
        // Export contacts CSV
        if (currentEdges && currentEdges.length > 0) {
          const csvLines = ['chain1,res1_num,res1_name,chain2,res2_num,res2_name,distance'];
          for (const e of currentEdges) {
            const parts1 = e.source.split('_');
            const parts2 = e.target.split('_');
            if (parts1.length === 3 && parts2.length === 3) {
              const c1 = parts1[0], res1 = parts1[1], num1 = parts1[2];
              const c2 = parts2[0], res2 = parts2[1], num2 = parts2[2];
              const dist = e.distance !== undefined ? e.distance.toFixed(3) : '';
              csvLines.push(`${c1},${num1},${res1},${c2},${num2},${res2},${dist}`);
            }
          }
          downloadText(`${currentChain1}_${currentChain2}_contacts.csv`, csvLines.join('\n'));
        }
        
        // Export edges CSV
        if (currentEdges && currentEdges.length > 0) {
          const csvLines = ['source,target' + (currentEdges.some(e => e.distance !== undefined) ? ',distance' : '')];
          for (const e of currentEdges) {
            if (e.distance !== undefined) {
              csvLines.push(`${e.source},${e.target},${e.distance.toFixed(3)}`);
            } else {
              csvLines.push(`${e.source},${e.target}`);
            }
          }
          downloadText(`${currentChain1}_${currentChain2}_edges.csv`, csvLines.join('\n'));
        }
        
        setStatus('Export completed: FASTA sequences and contact files downloaded.');
      } catch (err) {
        setStatus('Export error: ' + err.message);
      }
    });
    
    // Helper function to download text as file
    function downloadText(filename, text) {
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>


