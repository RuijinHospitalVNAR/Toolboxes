<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Circular Contact Map - Toolboxes</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
  <style>
    body { background: #f7f9fc; }
    .container-narrow { max-width: 960px; }
    .card { border: 1px solid #e7eaf0; box-shadow: 0 6px 16px rgba(0,0,0,0.06); }
    code { background:#f4f4f4; padding:2px 6px; border-radius:3px; }
  </style>
  <script defer src="https://buttons.github.io/buttons.js"></script>
  <script>
    function downloadScript() {
      window.location.href = '../scripts/circular_ribbon_contact_map.py';
    }
  </script>
  <meta name="description" content="Circular ribbon contact map generator for nanobody–antigen interface analysis." />
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-chord@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <!-- Google Analytics 4 -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-H00K0HSQWN"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-H00K0HSQWN');
  </script>
</head>
<body>
  <div class="container container-narrow py-4">
    <div class="text-center mb-4">
      <h1 class="fw-bold"><i class="fas fa-circle-notch"></i> Circular Contact Map</h1>
      <p class="text-muted m-0">Nanobody–antigen interface analysis with circular ribbon diagrams</p>
      <a class="github-button" href="https://github.com/RuijinHospitalVNAR/Toolboxes" data-size="large" data-show-count="true" aria-label="Star">Star</a>
      <div class="mt-2">
        <a class="btn btn-sm btn-outline-secondary me-2" href="https://ruijinhospitalvnar.github.io/Toolboxes/"><i class="fas fa-arrow-left"></i> Back to Home</a>
        <small class="text-muted">
          <i class="fas fa-eye"></i> Page views: <span id="pageViews">0</span>
        </small>
      </div>
    </div>

    <div class="card mb-3">
      <div class="card-body">
        <h5 class="card-title">What is this tool?</h5>
        <p class="card-text">
          This tool helps you generate a <strong>circular ribbon contact map</strong> to visualize
          residue–residue contacts between two protein chains (e.g., nanobody and antigen).
          It supports two workflows:
        </p>
        <ol>
          <li><strong>From mmCIF</strong>: extract sequences and contacts for two chains, then plot.</li>
          <li><strong>From edges.csv</strong>: directly plot from a Cytoscape-like <code>edges.csv</code> (source,target[,distance]).</li>
        </ol>
      </div>
    </div>

    <div class="card mb-3">
      <div class="card-body">
        <h5 class="card-title">Download</h5>
        <p class="card-text">Run locally with Python. Requires <code>pandas</code>, <code>holoviews[bokeh]</code>, <code>biopython</code>.</p>
        <button class="btn btn-primary" onclick="downloadScript()"><i class="fas fa-download"></i> Download Python script</button>
        <a class="btn btn-outline-secondary ms-2" target="_blank" href="../scripts/circular_ribbon_contact_map.py"><i class="fas fa-file-code"></i> View source</a>
        <p class="small text-muted mt-2">File: <code>scripts/circular_ribbon_contact_map.py</code></p>
      </div>
    </div>

    <div class="card mb-3">
      <div class="card-body">
        <h5 class="card-title">Quick start</h5>
        <p class="mb-1 fw-bold">Install dependencies</p>
        <pre class="mb-3"><code>pip install pandas holoviews bokeh biopython matplotlib</code></pre>
        <p class="mb-1 fw-bold">A) From mmCIF (recommended)</p>
        <pre class="mb-3"><code>python scripts/circular_ribbon_contact_map.py --cif complex.cif --chain1 H --chain2 L --cutoff 5.0 --output H_L_contact_map.html</code></pre>
        <ul>
          <li>Outputs sequences (FASTA), contact pairs (CSV), and an HTML plot (interactive).</li>
          <li>Use <code>--output &lt;file.png&gt;</code> to render PNG (requires bokeh + selenium + pillow).</li>
        </ul>
        <p class="mb-1 fw-bold">B) From edges.csv</p>
        <pre class="mb-0"><code># edges.csv columns: source,target[,distance]
python scripts/circular_ribbon_contact_map.py edges.csv --output contact_map.html</code></pre>
      </div>
    </div>

    <div class="card mb-3">
      <div class="card-body">
        <h5 class="card-title">Tips</h5>
        <ul class="mb-0">
          <li>Residue node naming format: <code>Chain_RES3_Num</code> (e.g., <code>A_ARG_100</code>).</li>
          <li>Distance (optional) can control edge width; closer contacts draw thicker ribbons.</li>
          <li>Recommended distance cutoff for contacts: 4.5–5.0 Å.</li>
        </ul>
      </div>
    </div>

    <!-- Web App: upload & draw chord -->
    <div class="card mb-3">
      <div class="card-body">
        <h5 class="card-title">Web app (no backend) — Upload and draw</h5>
        <p class="text-muted">Upload one of the following: <code>edges.csv</code>, <code>edges.json</code>, or <code>.cif</code>. For CIF, choose two chains and cutoff.</p>
        <div class="row g-3 align-items-end">
          <div class="col-md-6">
            <label class="form-label">Upload file (csv/json/cif)</label>
            <input id="fileInput" type="file" class="form-control" accept=".csv,.json,.cif" />
          </div>
          <div class="col-md-2">
            <label class="form-label">Chain 1</label>
            <select id="chain1" class="form-select"></select>
          </div>
          <div class="col-md-2">
            <label class="form-label">Chain 2</label>
            <select id="chain2" class="form-select"></select>
          </div>
          <div class="col-md-2">
            <label class="form-label">Cutoff (Å)</label>
            <input id="cutoff" type="number" class="form-control" value="5.0" min="3.0" max="10.0" step="0.1" />
          </div>
          <div class="col-md-12">
            <div class="form-check mt-2">
              <input class="form-check-input" type="checkbox" value="" id="useWeighting" />
              <label class="form-check-label" for="useWeighting">
                Use distance weighting (closer contacts → thicker ribbons)
              </label>
            </div>
            <div class="form-check mt-2">
              <input class="form-check-input" type="checkbox" value="" id="showUnconnected" checked />
              <label class="form-check-label" for="showUnconnected">
                Show unconnected nodes (hide by setting node width to 0 or making transparent)
              </label>
            </div>
          </div>
        </div>
        <div class="mt-3">
          <button id="btnParse" class="btn btn-primary"><i class="fas fa-play"></i> Parse & Draw</button>
          <button id="btnExport" class="btn btn-outline-success ms-2" style="display:none;"><i class="fas fa-download"></i> Export Sequences & Contacts</button>
          <div class="btn-group ms-2" id="btnExportImage" style="display:none;">
            <button type="button" class="btn btn-outline-primary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false" id="exportImageBtn">
              <i class="fas fa-image"></i> Export Image
            </button>
            <ul class="dropdown-menu" id="exportImageMenu">
              <li><a class="dropdown-item" href="#" data-format="png"><i class="fas fa-file-image"></i> PNG</a></li>
              <li><a class="dropdown-item" href="#" data-format="jpg"><i class="fas fa-file-image"></i> JPG</a></li>
              <li><a class="dropdown-item" href="#" data-format="pdf"><i class="fas fa-file-pdf"></i> PDF</a></li>
              <li><a class="dropdown-item" href="#" data-format="svg"><i class="fas fa-file-code"></i> SVG</a></li>
              <li><hr class="dropdown-divider"></li>
              <li><a class="dropdown-item" href="#" data-format="emf-info"><i class="fas fa-info-circle"></i> EMF (see note)</a></li>
            </ul>
          </div>
          <small id="status" class="text-muted ms-2"></small>
        </div>
        <div class="mt-4" id="vizContainer">
          <svg id="chordSvg" width="760" height="760"></svg>
          <div class="mt-3" id="legendBox">
            <div class="small text-muted mb-2"><i class="fas fa-info-circle"></i> <strong>Legend:</strong></div>
            <div class="small">
              <div class="mb-1"><strong>Node colors:</strong> Same color for all nodes in the same chain</div>
              <div class="d-flex flex-wrap gap-2 mb-2">
                <span><span style="display:inline-block;width:12px;height:12px;background:#FFA500;border:1px solid #ccc;"></span> Chain 1 (orange)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#20B2AA;border:1px solid #ccc;"></span> Chain 2 (teal)</span>
              </div>
              <div class="mb-1"><strong>Ring colors (unconnected nodes):</strong> Different from node colors, but still chain-based</div>
              <div class="d-flex flex-wrap gap-2 mb-2">
                <span><span style="display:inline-block;width:12px;height:12px;background:#FF6600;border:1px solid #ccc;"></span> Chain 1 ring (darker orange)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#006666;border:1px solid #ccc;"></span> Chain 2 ring (darker teal)</span>
              </div>
              <div class="mb-1"><strong>Ribbon colors:</strong> Based on source node amino acid properties</div>
              <div class="d-flex flex-wrap gap-2 mb-2">
                <span><span style="display:inline-block;width:12px;height:12px;background:#000000;border:1px solid #ccc;"></span> Cysteine (black)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#FF7744;border:1px solid #ccc;"></span> Hydrophobic (orange-red)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#87CEFA;border:1px solid #ccc;"></span> Polar (light blue)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#FF0000;border:1px solid #ccc;"></span> Acidic (red)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#B565A7;border:1px solid #ccc;"></span> Basic (purple)</span>
                <span><span style="display:inline-block;width:12px;height:12px;background:#AAAAAA;border:1px solid #ccc;"></span> Other (gray)</span>
              </div>
              <div class="mb-1"><strong>Ribbon thickness:</strong> When "Use distance weighting" is enabled, closer contacts contribute more weight; otherwise each contact contributes equally.</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="text-center text-muted mt-4">
      <small>&copy; 2025 Toolboxes. MIT License.</small>
    </div>
  </div>
  <script>
    // Page view counter using Google Analytics API + local storage fallback
    (function() {
      const pageKey = 'circular_contact_map_views';
      const sessionKey = 'circular_contact_map_session';
      const viewElement = document.getElementById('pageViews');
      
      // Google Apps Script Web App URL for GA4 statistics
      const GA_STATS_API = 'https://script.google.com/macros/s/AKfycbzQ6qwA0NqrIYUgnwJnvep2QB2nRYmU6LI8KB8wwtp3QKi6ORqscPjF3Vv2VQ-6SPi6/exec';
      
      // Check if this is a new session
      let sessionId = sessionStorage.getItem(sessionKey);
      if (!sessionId) {
        // New session - increment view count
        sessionId = Date.now().toString(36) + Math.random().toString(36).substr(2);
        sessionStorage.setItem(sessionKey, sessionId);
        
        // Increment local counter
        const currentLocal = parseInt(localStorage.getItem(pageKey) || '0', 10);
        localStorage.setItem(pageKey, (currentLocal + 1).toString());
        if (viewElement) {
          viewElement.textContent = (currentLocal + 1).toLocaleString();
        }
        
        // Track page view in Google Analytics (if gtag is available)
        if (typeof gtag !== 'undefined') {
          gtag('event', 'page_view', {
            'page_title': 'Circular Contact Map',
            'page_location': window.location.href
          });
        }
      } else {
        // Existing session - just display current count
        const localViews = parseInt(localStorage.getItem(pageKey) || '0', 10);
        if (viewElement) {
          viewElement.textContent = localViews.toLocaleString();
        }
      }
      
      // Try to fetch from Google Analytics API (non-blocking)
      // Only fetch if API URL is configured
      if (GA_STATS_API && !GA_STATS_API.includes('YOUR_SCRIPT_ID')) {
        fetch(`${GA_STATS_API}?tool=circular_contact_map`)
          .then(response => response.json())
          .then(data => {
            if (data && !data.error && data.views && viewElement) {
              // Update with GA data
              viewElement.textContent = data.views.toLocaleString();
            }
          })
          .catch(error => {
            // Silent fail - keep local storage values
            console.warn('Failed to fetch GA stats from API:', error);
          });
      }
    })();
  </script>
  <script>
    // Amino acid property classification (matching Python version)
    const hydrophobic = new Set(['ALA', 'VAL', 'LEU', 'ILE', 'MET', 'PHE', 'TRP', 'PRO', 'GLY']);
    const polar = new Set(['SER', 'THR', 'TYR', 'ASN', 'GLN']);
    const acidic = new Set(['ASP', 'GLU']);
    const basic = new Set(['LYS', 'ARG', 'HIS']);
    
    // Color mapping (matching Python version with alpha 0.75)
    function getAAColor(resname) {
      const res = resname.toUpperCase();
      if (res === 'CYS') return '#000000'; // black
      if (hydrophobic.has(res)) return '#FF7744'; // orange-red
      if (polar.has(res)) return '#87CEFA'; // light blue
      if (acidic.has(res)) return '#FF0000'; // red
      if (basic.has(res)) return '#B565A7'; // purple
      return '#AAAAAA'; // default gray
    }
    
    // Extract residue name from node label (format: Chain_RES3_Num)
    function extractResname(nodeLabel) {
      const parts = nodeLabel.split('_');
      if (parts.length >= 2) return parts[1];
      return null;
    }
    
    // Extract chain ID from node label
    function extractChain(nodeLabel) {
      const parts = nodeLabel.split('_');
      if (parts.length >= 1) return parts[0];
      return null;
    }
    
    // Get node color based on chain (all nodes in same chain have same color)
    // If chain1/chain2 are provided, use them; otherwise auto-detect from nodes
    function getNodeColor(nodeLabel, chain1, chain2, allNodes) {
      const chain = extractChain(nodeLabel);
      if (!chain) return '#AAAAAA'; // default gray if no chain found
      
      // If chain1/chain2 are provided, use them
      if (chain1 && chain2) {
        if (chain === chain1) return '#FFA500'; // orange for chain1
        if (chain === chain2) return '#20B2AA'; // teal for chain2
      }
      
      // Auto-detect chains from nodes if chain1/chain2 not provided
      if (allNodes && allNodes.length > 0) {
        const chains = Array.from(new Set(allNodes.map(n => extractChain(n)).filter(c => c)));
        if (chains.length >= 2) {
          // First chain gets chain1 color, second gets chain2 color
          if (chain === chains[0]) return '#FFA500'; // orange for first chain
          if (chain === chains[1]) return '#20B2AA'; // teal for second chain
        } else if (chains.length === 1 && chain === chains[0]) {
          return '#FFA500'; // orange for single chain
        }
      }
      
      return '#AAAAAA'; // default gray for other chains
    }
    
    // Get ring color based on chain (different from node colors, but still chain-based)
    // Chain1: darker orange (#FF6600), Chain2: darker teal (#006666)
    function getRingColor(nodeLabel, chain1, chain2, allNodes) {
      const chain = extractChain(nodeLabel);
      if (!chain) return '#AAAAAA'; // default gray if no chain found
      
      // If chain1/chain2 are provided, use them
      if (chain1 && chain2) {
        if (chain === chain1) return '#FF6600'; // darker orange for chain1
        if (chain === chain2) return '#006666'; // darker teal for chain2
      }
      
      // Auto-detect chains from nodes if chain1/chain2 not provided
      if (allNodes && allNodes.length > 0) {
        const chains = Array.from(new Set(allNodes.map(n => extractChain(n)).filter(c => c)));
        if (chains.length >= 2) {
          // First chain gets chain1 color, second gets chain2 color
          if (chain === chains[0]) return '#FF6600'; // darker orange for first chain
          if (chain === chains[1]) return '#006666'; // darker teal for second chain
        } else if (chains.length === 1 && chain === chains[0]) {
          return '#FF6600'; // darker orange for single chain
        }
      }
      
      return '#AAAAAA'; // default gray for other chains
    }
    
    // Get edge color based on source node amino acid property
    function getEdgeColor(sourceNode) {
      const resname = extractResname(sourceNode);
      if (resname) return getAAColor(resname);
      return '#AAAAAA'; // default gray
    }
    
    // Extract sequence from CA atoms or all atoms
    function extractSequence(allAtoms, chainId) {
      // Extract CA atoms for this chain
      const caAtoms = allAtoms.filter(a => a.chain === chainId && a.atomId === 'CA');
      // Sort by residue number
      caAtoms.sort((a, b) => a.resnum - b.resnum);
      // Get unique residues (in case of duplicates)
      const seen = new Set();
      const unique = [];
      for (const r of caAtoms) {
        const key = `${r.resnum}_${r.resname}`;
        if (!seen.has(key)) {
          seen.add(key);
          unique.push(r);
        }
      }
      return unique.map(r => r.resname);
    }
    
    // Three-letter to one-letter amino acid code
    const aa3to1 = {
      'ALA': 'A', 'CYS': 'C', 'ASP': 'D', 'GLU': 'E', 'PHE': 'F',
      'GLY': 'G', 'HIS': 'H', 'ILE': 'I', 'LYS': 'K', 'LEU': 'L',
      'MET': 'M', 'ASN': 'N', 'PRO': 'P', 'GLN': 'Q', 'ARG': 'R',
      'SER': 'S', 'THR': 'T', 'VAL': 'V', 'TRP': 'W', 'TYR': 'Y'
    };
    
    function resnameToSeq(resname) {
      return aa3to1[resname.toUpperCase()] || 'X';
    }
    
    // Identify interfaces (continuous residue segments)
    function identifyInterfaces(edges) {
      const contactNodes = new Set(edges.flatMap(e => [e.source, e.target]));
      const chainResnum = {};
      
      for (const node of contactNodes) {
        const parts = node.split('_');
        if (parts.length === 3) {
          const chain = parts[0];
          const num = parseInt(parts[2]);
          if (!isNaN(num)) {
            if (!chainResnum[chain]) chainResnum[chain] = [];
            chainResnum[chain].push(num);
          }
        }
      }
      
      const interfaces = [];
      for (const [chain, nums] of Object.entries(chainResnum)) {
        const sorted = [...new Set(nums)].sort((a, b) => a - b);
        let current = [];
        let lastNum = null;
        
        for (const num of sorted) {
          if (lastNum !== null && num === lastNum + 1) {
            current.push(num);
          } else {
            if (current.length >= 2) {
              interfaces.push({ chain, residues: [...current] });
            }
            current = [num];
          }
          lastNum = num;
        }
        if (current.length >= 2) {
          interfaces.push({ chain, residues: [...current] });
        }
      }
      
      return interfaces;
    }
    
    // Utilities
    function setStatus(msg) { document.getElementById('status').textContent = msg; }
    function parseCSV(text) {
      const lines = text.replace(/\r\n/g,'\n').split('\n').filter(x=>x.trim().length>0);
      const header = lines[0].split(',').map(s=>s.trim());
      const idxS = header.findIndex(h=>/^source$/i.test(h));
      const idxT = header.findIndex(h=>/^target$/i.test(h));
      const idxD = header.findIndex(h=>/^distance$/i.test(h));
      if (idxS<0 || idxT<0) throw new Error('CSV must contain source,target columns');
      const edges=[];
      for (let i=1;i<lines.length;i++){
        const parts = lines[i].split(',');
        const s = (parts[idxS]||'').trim();
        const t = (parts[idxT]||'').trim();
        if (!s||!t) continue;
        const d = idxD>=0 ? Number(parts[idxD]) : undefined;
        edges.push({source:s,target:t,distance:(Number.isFinite(d)?d:undefined)});
      }
      return edges;
    }
    function parseJSON(text){
      const data = JSON.parse(text);
      if (Array.isArray(data)) return data; // assume array of edges
      if (Array.isArray(data.edges)) return data.edges;
      throw new Error('JSON must be an array of edges or {edges:[...]}.');
    }
    // Standard amino acids (3-letter codes)
    const standardAAs = new Set([
      'ALA', 'CYS', 'ASP', 'GLU', 'PHE', 'GLY', 'HIS', 'ILE', 
      'LYS', 'LEU', 'MET', 'ASN', 'PRO', 'GLN', 'ARG', 'SER', 
      'THR', 'VAL', 'TRP', 'TYR'
    ]);
    
    // Enhanced CIF parser: read atom_site loop, collect all atoms (not just CA)
    // This matches Python version's approach of checking all non-hydrogen atoms
    function parseCIF_AllAtoms(text){
      const lines = text.split(/\r?\n/);
      let inLoop=false; const headerCols={}; const allAtoms=[];
      for(const raw of lines){
        const line = raw.trim(); if(!line) continue;
        if (line.startsWith('loop_')) { inLoop=false; for(const k in headerCols) delete headerCols[k]; continue; }
        if (line.startsWith('_atom_site.')) { inLoop=true; const name=line.replace('_atom_site.','').trim(); headerCols[name]=Object.keys(headerCols).length; continue; }
        if (inLoop && !line.startsWith('#')){
          const parts=line.split(/\s+/);
          // Try label_asym_id first, fallback to auth_asym_id
          const ci=headerCols['label_asym_id'] != null ? headerCols['label_asym_id'] : headerCols['auth_asym_id'];
          const ri=headerCols['label_seq_id'] != null ? headerCols['label_seq_id'] : headerCols['auth_seq_id'];
          const xi=headerCols['Cartn_x'], yi=headerCols['Cartn_y'], zi=headerCols['Cartn_z'];
          const rn=headerCols['label_comp_id'] != null ? headerCols['label_comp_id'] : headerCols['auth_comp_id'];
          const li=headerCols['label_atom_id'] != null ? headerCols['label_atom_id'] : headerCols['auth_atom_id'];
          const ic=headerCols['pdbx_PDB_ins_code']; // insertion code
          const ts=headerCols['type_symbol']; // type symbol (element)
          
          if([ci,ri,xi,yi,zi,rn,li].some(v=>v==null)) continue;
          if (parts.length<=Math.max(ci,ri,xi,yi,zi,rn,li)) continue;
          
          // Check if standard amino acid and no insertion code (or empty insertion code)
          const resname = parts[rn];
          if (!standardAAs.has(resname)) continue;
          
          const insCode = ic != null ? (parts[ic] || '').trim() : '';
          if (insCode && insCode !== '?') continue; // Skip residues with insertion codes
          
          // Skip hydrogen atoms - use type_symbol if available, otherwise check atom name
          const atomId = parts[li];
          let isHydrogen = false;
          if (ts != null && parts[ts]) {
            // Use type_symbol if available (most reliable)
            isHydrogen = parts[ts].trim().toUpperCase() === 'H';
          } else {
            // Fallback: check atom name pattern
            // Hydrogen atoms typically: H, HA, HB, HB1, HB2, HD1, HD2, HE1, HE2, HG1, HG2, etc.
            // Pattern: starts with 'H' and may be followed by letters or numbers
            isHydrogen = atomId === 'H' || (atomId.length > 1 && atomId[0] === 'H' && 
                (atomId[1] === 'A' || atomId[1] === 'B' || atomId[1] === 'D' || 
                 atomId[1] === 'E' || atomId[1] === 'G' || atomId[1] === 'Z' || 
                 atomId[1] === 'H' || /^\d/.test(atomId.slice(1))));
          }
          if (isHydrogen) continue; // Skip hydrogen atoms
          
          const rec={
            chain: parts[ci],
            resnum: Number(parts[ri]),
            resname: resname,
            atomId: atomId,
            x: Number(parts[xi]), 
            y: Number(parts[yi]), 
            z: Number(parts[zi]),
          };
          if (Number.isFinite(rec.x) && Number.isFinite(rec.y) && Number.isFinite(rec.z) && 
              !isNaN(rec.resnum)) {
            allAtoms.push(rec);
          }
        }
      }
      return allAtoms; // [{chain,resnum,resname,atomId,x,y,z}]
    }
    
    // Calculate contacts using all non-hydrogen atoms (matching Python version)
    function calcContactsFromAtoms(allAtoms, chain1, chain2, cutoff){
      // Group atoms by residue
      const residues1 = {};
      const residues2 = {};
      
      for(const atom of allAtoms){
        if(atom.chain === chain1){
          const key = `${atom.resnum}_${atom.resname}`;
          if (!residues1[key]) residues1[key] = [];
          residues1[key].push(atom);
        } else if(atom.chain === chain2){
          const key = `${atom.resnum}_${atom.resname}`;
          if (!residues2[key]) residues2[key] = [];
          residues2[key].push(atom);
        }
      }
      
      const cutoff2 = cutoff*cutoff;
      const edges = [];
      const seenContacts = new Set(); // Avoid duplicate contacts
      
      // For each residue pair, check all atom pairs
      for(const key1 in residues1){
        const res1 = residues1[key1];
        const [resnum1, resname1] = key1.split('_');
        
        for(const key2 in residues2){
          const res2 = residues2[key2];
          const [resnum2, resname2] = key2.split('_');
          
          // Check if any atom pair is within cutoff
          let found = false;
          let minDist = Infinity;
          
          for(const atom1 of res1){
            for(const atom2 of res2){
              const dx = atom1.x - atom2.x;
              const dy = atom1.y - atom2.y;
              const dz = atom1.z - atom2.z;
              const d2 = dx*dx + dy*dy + dz*dz;
              
              if (d2 <= cutoff2){
                found = true;
                const dist = Math.sqrt(d2);
                if (dist < minDist) minDist = dist;
              }
            }
          }
          
          if (found){
            const contactKey = `${chain1}_${resname1}_${resnum1}-${chain2}_${resname2}_${resnum2}`;
            if (!seenContacts.has(contactKey)){
              seenContacts.add(contactKey);
              const s = `${chain1}_${resname1}_${resnum1}`;
              const t = `${chain2}_${resname2}_${resnum2}`;
              edges.push({source:s, target:t, distance:minDist});
            }
          }
        }
      }
      
      return edges;
    }
    
    // Extract CA atoms for sequence extraction (backward compatibility)
    function extractCAFromAtoms(allAtoms){
      const caAtoms = [];
      const seen = new Set();
      for(const atom of allAtoms){
        if(atom.atomId === 'CA'){
          const key = `${atom.chain}_${atom.resnum}_${atom.resname}`;
          if(!seen.has(key)){
            seen.add(key);
            caAtoms.push({
              chain: atom.chain,
              resnum: atom.resnum,
              resname: atom.resname,
              x: atom.x,
              y: atom.y,
              z: atom.z
            });
          }
        }
      }
      return caAtoms;
    }
    // Extract residue number from node label (format: Chain_RES3_Num)
    function extractResnum(nodeLabel) {
      const parts = nodeLabel.split('_');
      if (parts.length >= 3) {
        const num = parseInt(parts[2]);
        return isNaN(num) ? 0 : num;
      }
      return 0;
    }
    
    // Get all nodes from CIF data (for proper ordering)
    function getAllNodesFromCIF(allAtoms, chain1, chain2) {
      const nodes = new Set();
      for (const atom of allAtoms) {
        if (atom.atomId === 'CA' && (atom.chain === chain1 || atom.chain === chain2)) {
          const nodeLabel = `${atom.chain}_${atom.resname}_${atom.resnum}`;
          nodes.add(nodeLabel);
        }
      }
      return Array.from(nodes);
    }
    
    // Sort and arrange nodes by chain (matching Python version)
    // Order: chain2_nodes + other_nodes + chain1_nodes
    function arrangeNodesByChain(allNodes, chain1, chain2) {
      if (!chain1 || !chain2 || !allNodes || allNodes.length === 0) {
        // Fallback: just sort by chain and residue number
        return allNodes.sort((a, b) => {
          const chainA = extractChain(a);
          const chainB = extractChain(b);
          if (chainA !== chainB) return chainA.localeCompare(chainB);
          return extractResnum(a) - extractResnum(b);
        });
      }
      
      // Group by chain
      const chain1Nodes = [];
      const chain2Nodes = [];
      const otherNodes = [];
      
      for (const node of allNodes) {
        const chain = extractChain(node);
        if (chain === chain1) {
          chain1Nodes.push(node);
        } else if (chain === chain2) {
          chain2Nodes.push(node);
        } else {
          otherNodes.push(node);
        }
      }
      
      // Sort each group by residue number
      const sortByResnum = (a, b) => extractResnum(a) - extractResnum(b);
      chain1Nodes.sort(sortByResnum);
      chain2Nodes.sort(sortByResnum);
      otherNodes.sort(sortByResnum);
      
      // Return in Python version order: chain2 + other + chain1
      return [...chain2Nodes, ...otherNodes, ...chain1Nodes];
    }
    
    // Chord rendering via d3 (with amino acid-based coloring)
    let currentEdges = null;
    let currentChain1 = null;
    let currentChain2 = null;
    
    function renderChord(edges, chain1, chain2){
      currentEdges = edges;
      currentChain1 = chain1;
      currentChain2 = chain2;
      
      const svg = d3.select('#chordSvg');
      svg.selectAll('*').remove();
      const width=760, height=760, innerRadius= Math.min(width, height)*0.5 - 80, outerRadius=innerRadius+30; // Increased to 30 for thicker nodes
      
      // Get all nodes - if we have CIF data, get all nodes from both chains
      let allNodes = Array.from(new Set(edges.flatMap(e=>[e.source,e.target])));
      if (cachedCIF && chain1 && chain2) {
        // Get all nodes from CIF (including unconnected ones)
        const allNodesFromCIF = getAllNodesFromCIF(cachedCIF, chain1, chain2);
        // Merge with connected nodes
        const connectedNodesSet = new Set(allNodes);
        for (const node of allNodesFromCIF) {
          connectedNodesSet.add(node);
        }
        allNodes = Array.from(connectedNodesSet);
      }
      
      // Arrange nodes by chain (chain2 first, then chain1)
      allNodes = arrangeNodesByChain(allNodes, chain1, chain2);
      
      const index = new Map(allNodes.map((n,i)=>[n,i]));
      const N = allNodes.length; const matrix = Array.from({length:N},()=>Array(N).fill(0));
      
      // Distance weighting setup
      const useW = document.getElementById('useWeighting').checked;
      const dvals = edges.map(e=>e.distance).filter(d=>Number.isFinite(d));
      const dmin = dvals.length? Math.min(...dvals): 0;
      const dmax = dvals.length? Math.max(...dvals): 1;
      function weight(e){
        if (!useW || !Number.isFinite(e.distance)) return 1.0;
        if (dmax<=dmin) return 1.0;
        // Map distance to [0.5, 5.0] (closer → thicker)
        const t = (e.distance - dmin) / (dmax - dmin);
        return 5.0 - 4.5*t; // 5.0 (close) .. 0.5 (far)
      }
      
      // Build edge color mapping (based on source node)
      // For each edge, store color based on source node
      // Since matrix is symmetric, we need to track which direction has which color
      const edgeColorMap = new Map();
      const connectedNodesSet = new Set(edges.flatMap(e=>[e.source,e.target]));
      
      for(const e of edges){
        const i=index.get(e.source), j=index.get(e.target);
        if (i==null || j==null) continue;
        const w = weight(e);
        matrix[i][j] += w; matrix[j][i] += w;
        // Store edge color based on source node (direction from i to j)
        const color = getEdgeColor(e.source);
        edgeColorMap.set(`${i}-${j}`, color);
        // For reverse direction, we could use target color, but for consistency use source
        if (!edgeColorMap.has(`${j}-${i}`)) {
          edgeColorMap.set(`${j}-${i}`, color);
        }
      }
      
      // Add minimal self-loop for unconnected nodes to ensure they display with chain colors
      // Use a small value (0.1) so unconnected nodes have smaller angles
      const unconnectedNodes = allNodes.filter(n => !connectedNodesSet.has(n));
      for (const node of unconnectedNodes) {
        const i = index.get(node);
        if (i != null) {
          // Use a small value (0.1) - much smaller than connected nodes
          // This ensures unconnected nodes have minimal angle but still display
          matrix[i][i] = 0.1;
          // Use transparent color so no visible ribbon is drawn
          edgeColorMap.set(`${i}-${i}`, 'rgba(0,0,0,0)');
        }
      }
      
      // Helper function to get edge color for a chord
      function getChordColor(chord) {
        const srcIdx = chord.source.index;
        const tgtIdx = chord.target.index;
        // Check if this is a self-loop (unconnected node)
        if (srcIdx === tgtIdx) {
          const selfColor = edgeColorMap.get(`${srcIdx}-${srcIdx}`);
          if (selfColor === 'rgba(0,0,0,0)') return selfColor; // Transparent for unconnected nodes
        }
        // Try to find color based on source node of the chord
        // Check if there's an edge from source to target
        const color1 = edgeColorMap.get(`${srcIdx}-${tgtIdx}`);
        if (color1) return color1;
        // Otherwise use color from target to source
        const color2 = edgeColorMap.get(`${tgtIdx}-${srcIdx}`);
        if (color2) return color2;
        // Fallback: use color based on source node
        return getEdgeColor(allNodes[srcIdx]);
      }
      
      const chord = d3.chord().padAngle(0.02).sortSubgroups(d3.descending)(matrix);
      const arc = d3.arc()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius)
        .cornerRadius(0); // No corner radius to avoid edge artifacts
      const ribbon = d3.ribbon().radius(innerRadius);
      const g = svg.attr('viewBox', [-width/2, -height/2, width, height]).append('g');

      // Ribbons (edges) - color by source node amino acid property (drawn first, behind everything)
      // Skip self-loops (unconnected nodes) to avoid inner lines
      g.append('g')
        .attr('fill-opacity',0.85)
        .selectAll('path')
        .data(chord.filter(c => c.source.index !== c.target.index)) // Filter out self-loops
        .join('path')
        .attr('d', ribbon)
        .attr('fill', getChordColor)
        .attr('stroke', '#fff')
        .attr('stroke-width', 0.5);

      // Groups (nodes) - color by chain (all nodes in same chain have same color)
      const group = g.append('g')
        .selectAll('g')
        .data(chord.groups)
        .join('g');
      
      // Check if unconnected nodes should be shown
      const showUnconnected = document.getElementById('showUnconnected').checked;
      
      // Add a ring layer only for unconnected nodes (width is 15, stroke width is 5)
      // Ring width = 15
      // Stroke width = 5
      // Only unconnected nodes need the ring (connected nodes don't need it)
      // Ring color is different from node color, but still chain-based
      const ringWidth = 15;
      const ringArc = d3.arc().innerRadius(outerRadius).outerRadius(outerRadius + ringWidth);
      group.append('path')
        .attr('d', ringArc)
        .attr('fill', 'none') // No fill, only stroke (ring)
        .attr('stroke', d=>{
          // Only show ring for unconnected nodes, colored by chain (different from node color)
          const nodeLabel = allNodes[d.index];
          if (connectedNodesSet.has(nodeLabel)) return 'none';
          return getRingColor(nodeLabel, chain1, chain2, allNodes);
        })
        .attr('stroke-width', 5) // Stroke width is 5
        .attr('stroke-linecap', 'butt'); // Butt ends (no extension beyond path)
      
      // Node arcs (on top of the ring, with fill)
      // Use a slightly larger innerRadius to avoid inner edge line rendering
      const arcForNodes = d3.arc()
        .innerRadius(innerRadius + 1) // Slightly larger to hide inner edge (increased from 0.5 to 1)
        .outerRadius(outerRadius)
        .cornerRadius(0);
      group.append('path')
        .attr('d', arcForNodes)
        .attr('fill', d=>{
          const nodeLabel = allNodes[d.index];
          // Make unconnected nodes transparent
          if (!connectedNodesSet.has(nodeLabel)) {
            return 'rgba(0,0,0,0)'; // Transparent
          }
          return getNodeColor(nodeLabel, chain1, chain2, allNodes);
        })
        .attr('opacity', d=>{
          const nodeLabel = allNodes[d.index];
          // Make unconnected nodes transparent
          if (!connectedNodesSet.has(nodeLabel)) {
            return 0; // Fully transparent
          }
          return 1; // Fully opaque
        })
        .attr('stroke', 'none') // No stroke to avoid lines at boundaries
        .attr('stroke-width', 0) // Explicitly set stroke width to 0
        .attr('vector-effect', 'non-scaling-stroke'); // Prevent stroke scaling artifacts
      
      group.append('text')
        .each(d=>{d.angle=(d.startAngle+d.endAngle)/2;})
        .attr('dy','.35em')
        .attr('transform', d=>`rotate(${d.angle*180/Math.PI-90}) translate(${outerRadius+6}) ${d.angle>Math.PI?"rotate(180)":''}`)
        .attr('text-anchor', d=>d.angle>Math.PI?'end':null)
        .style('font-size','9px')
        .text(d=> {
          // Only show label for connected nodes, not for unconnected nodes
          const nodeLabel = allNodes[d.index];
          return connectedNodesSet.has(nodeLabel) ? nodeLabel : '';
        });
      
      // Show export buttons
      if (cachedCIF && chain1 && chain2) {
        document.getElementById('btnExport').style.display = 'inline-block';
      } else {
        document.getElementById('btnExport').style.display = 'none';
      }
      // Show image export button if we have rendered the chart
      if (edges && edges.length > 0) {
        document.getElementById('btnExportImage').style.display = 'inline-block';
      } else {
        document.getElementById('btnExportImage').style.display = 'none';
      }
    }
    
    // Export image function
    function exportImage(format) {
      const svg = document.getElementById('chordSvg');
      if (!svg) {
        setStatus('No chart to export. Please parse and draw first.');
        return;
      }
      
      setStatus('Exporting image...');
      
      try {
        if (format === 'svg') {
          // Export as SVG with inline styles
          const svgClone = svg.cloneNode(true);
          
          // Add namespace if not present
          if (!svgClone.getAttribute('xmlns')) {
            svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
          }
          
          // Serialize SVG
          const svgData = new XMLSerializer().serializeToString(svgClone);
          
          // Add XML declaration and create blob
          const svgWithDeclaration = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgData;
          const svgBlob = new Blob([svgWithDeclaration], { type: 'image/svg+xml;charset=utf-8' });
          const svgUrl = URL.createObjectURL(svgBlob);
          const downloadLink = document.createElement('a');
          downloadLink.href = svgUrl;
          downloadLink.download = 'circular_contact_map.svg';
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
          URL.revokeObjectURL(svgUrl);
          setStatus('SVG exported successfully. You can convert it to EMF using Inkscape or Adobe Illustrator.');
          return;
        }
        
        // For PNG, JPG, PDF: convert SVG to canvas first
        const svgData = new XMLSerializer().serializeToString(svg);
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);
        
        img.onload = function() {
          // Set canvas size to match SVG
          canvas.width = svg.width.baseVal.value || 760;
          canvas.height = svg.height.baseVal.value || 760;
          
          // Draw SVG to canvas
          ctx.drawImage(img, 0, 0);
          
          if (format === 'png' || format === 'jpg') {
            // Export as PNG or JPG
            const mimeType = format === 'png' ? 'image/png' : 'image/jpeg';
            const quality = format === 'jpg' ? 0.95 : 1.0;
            canvas.toBlob(function(blob) {
              const url = URL.createObjectURL(blob);
              const downloadLink = document.createElement('a');
              downloadLink.href = url;
              downloadLink.download = `circular_contact_map.${format}`;
              document.body.appendChild(downloadLink);
              downloadLink.click();
              document.body.removeChild(downloadLink);
              URL.revokeObjectURL(url);
              setStatus(`${format.toUpperCase()} exported successfully.`);
            }, mimeType, quality);
          } else if (format === 'pdf') {
            // Export as PDF using jsPDF
            if (typeof window.jspdf === 'undefined') {
              setStatus('PDF export library not loaded. Please refresh the page.');
              return;
            }
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
              orientation: 'landscape',
              unit: 'px',
              format: [canvas.width, canvas.height]
            });
            
            const imgData = canvas.toDataURL('image/png');
            pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
            pdf.save('circular_contact_map.pdf');
            setStatus('PDF exported successfully.');
          }
          
          URL.revokeObjectURL(url);
        };
        
        img.onerror = function() {
          setStatus('Error exporting image. Please try again.');
          URL.revokeObjectURL(url);
        };
        
        img.src = url;
      } catch (error) {
        console.error('Export error:', error);
        setStatus('Export error: ' + error.message);
      }
    }

    // Wire UI
    const input = document.getElementById('fileInput');
    const sel1 = document.getElementById('chain1');
    const sel2 = document.getElementById('chain2');
    const cutoffEl = document.getElementById('cutoff');
    const useWeightingEl = document.getElementById('useWeighting');
    let cachedCIF = null; // store all atoms after parsing
    
    // Re-render when distance weighting option changes
    useWeightingEl.addEventListener('change', () => {
      if (currentEdges) {
        renderChord(currentEdges, currentChain1, currentChain2);
      }
    });
    
    // Re-render when show unconnected nodes option changes
    document.getElementById('showUnconnected').addEventListener('change', () => {
      if (currentEdges) {
        renderChord(currentEdges, currentChain1, currentChain2);
      }
    });

    input.addEventListener('change', async (e)=>{
      setStatus(''); sel1.innerHTML=''; sel2.innerHTML=''; cachedCIF=null;
      document.getElementById('btnExport').style.display = 'none';
      const file=e.target.files && e.target.files[0]; if(!file) return;
      const name=file.name.toLowerCase(); const buf=await file.text();
      try{
        if (name.endsWith('.csv')){
          const edges=parseCSV(buf); 
          // Try to detect chains from edges
          let c1 = null, c2 = null;
          if (edges.length > 0) {
            const chains = new Set(edges.flatMap(e => [
              extractChain(e.source), 
              extractChain(e.target)
            ]).filter(c => c));
            const chainArray = Array.from(chains);
            if (chainArray.length >= 2) {
              c1 = chainArray[0];
              c2 = chainArray[1];
            } else if (chainArray.length === 1) {
              c1 = chainArray[0];
            }
          }
          renderChord(edges, c1, c2); 
          setStatus(`Parsed ${edges.length} edges from CSV.`);
        } else if (name.endsWith('.json')){
          const edges=parseJSON(buf);
          // Try to detect chains from edges
          let c1 = null, c2 = null;
          if (edges.length > 0) {
            const chains = new Set(edges.flatMap(e => [
              extractChain(e.source), 
              extractChain(e.target)
            ]).filter(c => c));
            const chainArray = Array.from(chains);
            if (chainArray.length >= 2) {
              c1 = chainArray[0];
              c2 = chainArray[1];
            } else if (chainArray.length === 1) {
              c1 = chainArray[0];
            }
          }
          renderChord(edges, c1, c2); 
          setStatus(`Parsed ${edges.length} edges from JSON.`);
        } else if (name.endsWith('.cif')){
          const allAtoms=parseCIF_AllAtoms(buf); cachedCIF=allAtoms;
          const chains = Array.from(new Set(allAtoms.map(r=>r.chain)));
          chains.forEach(c=>{ const o=document.createElement('option'); o.value=c; o.textContent=c; sel1.appendChild(o.cloneNode(true)); sel2.appendChild(o); });
          setStatus(`Parsed CIF: detected chains [${chains.join(', ')}]. Choose chains and click Parse & Draw.`);
        } else {
          setStatus('Unsupported file type.');
        }
      }catch(err){ setStatus('Parse error: '+err.message); }
    });
    document.getElementById('btnParse').addEventListener('click', ()=>{
      const file=input.files && input.files[0]; if(!file){ setStatus('Please upload a file first.'); return; }
      const name=file.name.toLowerCase();
      if (name.endsWith('.cif')){
        if(!cachedCIF){ setStatus('CIF not parsed.'); return; }
        const c1=sel1.value, c2=sel2.value; const cutoff=Number(cutoffEl.value)||5.0;
        if(!c1||!c2||c1===c2){ setStatus('Please choose two different chains.'); return; }
        const edges=calcContactsFromAtoms(cachedCIF, c1, c2, cutoff);
        renderChord(edges, c1, c2); 
        const interfaces = identifyInterfaces(edges);
        let msg = `Computed ${edges.length} contacts @ cutoff ${cutoff} Å (using all non-H atoms).`;
        if (interfaces.length > 0) {
          msg += ` Found ${interfaces.length} interface segment(s).`;
        }
        setStatus(msg);
      }
    });
    
    // Export sequences and contacts
    document.getElementById('btnExport').addEventListener('click', ()=>{
      if (!cachedCIF || !currentChain1 || !currentChain2) {
        setStatus('No CIF data available for export.');
        return;
      }
      
      try {
        // Extract sequences
        const seq1 = extractSequence(cachedCIF, currentChain1);
        const seq2 = extractSequence(cachedCIF, currentChain2);
        const seq1Str = seq1.map(r => resnameToSeq(r)).join('');
        const seq2Str = seq2.map(r => resnameToSeq(r)).join('');
        
        // Export FASTA files
        const fasta1 = `>${currentChain1}\n${seq1Str}`;
        const fasta2 = `>${currentChain2}\n${seq2Str}`;
        
        downloadText(`${currentChain1}_sequence.fasta`, fasta1);
        downloadText(`${currentChain2}_sequence.fasta`, fasta2);
        
        // Export contacts CSV
        if (currentEdges && currentEdges.length > 0) {
          const csvLines = ['chain1,res1_num,res1_name,chain2,res2_num,res2_name,distance'];
          for (const e of currentEdges) {
            const parts1 = e.source.split('_');
            const parts2 = e.target.split('_');
            if (parts1.length === 3 && parts2.length === 3) {
              const c1 = parts1[0], res1 = parts1[1], num1 = parts1[2];
              const c2 = parts2[0], res2 = parts2[1], num2 = parts2[2];
              const dist = e.distance !== undefined ? e.distance.toFixed(3) : '';
              csvLines.push(`${c1},${num1},${res1},${c2},${num2},${res2},${dist}`);
            }
          }
          downloadText(`${currentChain1}_${currentChain2}_contacts.csv`, csvLines.join('\n'));
        }
        
        // Export edges CSV
        if (currentEdges && currentEdges.length > 0) {
          const csvLines = ['source,target' + (currentEdges.some(e => e.distance !== undefined) ? ',distance' : '')];
          for (const e of currentEdges) {
            if (e.distance !== undefined) {
              csvLines.push(`${e.source},${e.target},${e.distance.toFixed(3)}`);
            } else {
              csvLines.push(`${e.source},${e.target}`);
            }
          }
          downloadText(`${currentChain1}_${currentChain2}_edges.csv`, csvLines.join('\n'));
        }
        
        setStatus('Export completed: FASTA sequences and contact files downloaded.');
      } catch (err) {
        setStatus('Export error: ' + err.message);
      }
    });
    
    // Helper function to download text as file
    function downloadText(filename, text) {
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    // Show EMF format info
    function showEMFInfo() {
      alert('EMF (Enhanced Metafile) Format:\n\n' +
            'EMF is a Windows-specific vector format that cannot be directly generated in web browsers.\n\n' +
            'Alternative solutions:\n' +
            '1. Export as SVG, then use software like Inkscape, Adobe Illustrator, or Microsoft Office to convert SVG to EMF.\n' +
            '2. Export as PDF, then use conversion tools to convert PDF to EMF.\n\n' +
            'SVG format is recommended as it is a standard vector format that can be easily converted to EMF using desktop software.');
    }
    
    // Initialize export image dropdown menu
    document.addEventListener('DOMContentLoaded', function() {
      const exportMenu = document.getElementById('exportImageMenu');
      if (exportMenu) {
        exportMenu.addEventListener('click', function(e) {
          e.preventDefault();
          const target = e.target.closest('a');
          if (target) {
            const format = target.getAttribute('data-format');
            if (format === 'emf-info') {
              showEMFInfo();
            } else if (format && typeof exportImage === 'function') {
              exportImage(format);
            }
          }
        });
      }
    });
  </script>
</body>
</html>



